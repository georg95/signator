<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="shortcut icon" type="image/png" href="pwa/favicon.png">
  <link rel="manifest" href="pwa/manifest.json">
  <title>Signator</title>
</head>
  <style>
    html, body {
      height: 100%;
      width: 100%;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      padding: 20px;
      display: flex;
    }
    #output {
      margin: 0;
    }
    html, body, input, textarea, pre, button, select, option {
      font-size: 16px;
      font-family: 'Courier New', Courier, monospace;
      background-color: #222;
      color: bisque;
      outline: none;
    }
    button {
      cursor: pointer;
    }
    button:disabled {
      cursor: not-allowed;
      background-color: #333;
      color: bisque;
    }
    textarea {
      width: 100%;
      min-height: 60px;
    }
    input, select, option {
      width: 100%;
      height: 40px;
      margin-bottom: 20px;
    }
    video {
      display: block;
      background-color: #000;
      width: 100%;
    }
    .eth-logo {
      background-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 540 879.4'%3E%3Cpath d='m269.9 325.2-269.9 122.7 269.9 159.6 270-159.6z' opacity='.6'/%3E%3Cpath d='m0.1 447.8 269.9 159.6v-607.4z' opacity='.45'/%3E%3Cpath d='m270 0v607.4l269.9-159.6z' opacity='.8'/%3E%3Cpath d='m0 499 269.9 380.4v-220.9z' opacity='.45'/%3E%3Cpath d='m269.9 658.5v220.9l270.1-380.4z' opacity='.8'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: center;
      background-size: 70% 70%;
    }

    #account {
      flex: 1;
    }
    #account header {
      display: flex;
    }
    #account_setup_qr, #account_settings_qr {
      margin-top: 15px;
    }
    #account_addr {
      display: flex;
      align-items: center;
    }
    #tx_info {
      flex: 1;
      word-break: break-all;
    }
    #account header {
      position: relative;
    }
    #settings_button {
      font-size: 30px;
      width: 50px;
      height: 50px;
      position: absolute;
      margin: 0;
      padding: 0;
      right: 0;
      top: 0;
    }
    #fountain_progress {
      margin-top: 12px;
      width: 100%;
    }
    #initial {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }
    button {
      margin-top: 15px;
      width: 100%;
      height: 70px;
    }
    .pane {
      flex: 1;
      flex-direction: column;
      display: none;
      justify-content: space-between;
    }
    #generate_seed_canvas {
      flex: 1;
      border: 2px solid bisque;
      margin: 0 -20px;
    }
    .current-step {
      font-size: 32px;
      margin-bottom: 15px;
    }
    #enter_seed_canvas, #enter_password_canvas {
      flex: 1;
    }
    .action-buttons {
      display: flex;
    }
    .action-buttons button+button {
      margin-left: 15px;
    }
  </style>
<body>
<div id="initial" style="display: none;">
  <button onclick="generateSeed()">Create wallet</button>
  <button onclick="displaySeedInput()">Import from 12 words</button>
</div>
<div id="generate_seed" class="pane">
  <div class="current-step">
    1/4 - Write down these words with pen and paper
  </div>
  <canvas id="generate_seed_canvas"></canvas>
  <div class="action-buttons">
    <button class="back">Back</button>
    <button class="next">Next</button>
  </div>
</div>
<div id="enter_seed" class="pane">
  <div class="current-step">
    1/4
  </div>
  <canvas id="enter_seed_canvas"></canvas>
  <div class="action-buttons">
    <button class="back">Back</button>
    <button class="next">Import</button>
  </div>
</div>
<div id="enter_password" class="pane">
  <div class="current-step">
    2/4 Enter password
  </div>
  <canvas id="enter_password_canvas"></canvas>
  <div class="action-buttons">
    <button class="back">Back</button>
    <button class="next">Confirm</button>
  </div>
</div>
<div id="download_wallet" class="pane">
  <div class="current-step">
    3/4 Install Rabby wallet
  </div>
  <select onchange="displayWalletLink(event.target.value)"><option>Android</option><option>iOS</option></select>
  <canvas id="download_wallet_link"></canvas>
  <div class="action-buttons">
    <button class="back">Back</button>
    <button class="next">Next</button>
  </div>
</div>
<div id="connect_wallet" class="pane">
  <div class="current-step">
    4/4 Connect wallet
  </div>
  <p>
    Open Rabby wallet on your second device -><br />
    <b>*I already have a wallet*</b> -><br />
    <b>*Connect Hardware Wallets*</b> -><br />
    <b>*Keystone*</b> -><br />
    <b>*Next*</b> -><br />
  </p>
  <canvas id="account_setup_qr"></canvas>
  <div class="action-buttons">
    <button class="back">Back</button>
    <button class="next">Done</button>
  </div>
</div>
<div id="scan_transaction_qr" class="pane">
  <div class="current-step">
    1/4
  </div>
  <video id="qrcam" autoplay playsinline style="display: none;"></video>
  <canvas id="qrcanvas" style="display: none;" willReadFrequently></canvas>
  <progress id="fountain_progress" value="0" max="100" style="display: none;"></progress>
  <div class="action-buttons">
    <button class="back">Cancel</button>
  </div>
</div>
<div id="view_transaction" class="pane">
  <div class="current-step">
    2/4
  </div>
  <div id="tx_info"></div>
  <div class="action-buttons">
    <button class="back">Cancel</button>
    <button class="next">Sign</button>
  </div>
</div>
<div id="sign_transaction" class="pane">
  <div class="current-step">
    3/4
  </div>
  <canvas></canvas>
  <div class="action-buttons">
    <button class="back">Cancel</button>
    <button class="next">Sign</button>
  </div>
</div>
<div id="signed_transaction_qr" class="pane">
  <div class="current-step">
    4/4
  </div>
  <canvas id="qr_signed_tx"></canvas>
  <div class="action-buttons">
    <button class="back">Check again</button>
    <button class="next">Done</button>
  </div>
</div>
<div id="account" class="pane">
  <header>
    <div class="eth-logo" style="width: 50px; height: 50px;"></div>
    <div id="account_addr"></div>
    <button id="settings_button" onclick="triggerSettings()">⚙︎</button>
  </header>
  <div id="account_actions">
    <button id="scan_qr" onclick="scanTransactionQR()">Scan transaction QR</button>
  </div>
  <div id="account_settings" style="display: none;">
    <canvas id="account_settings_qr"></canvas>
    <button onclick="resetCache()">Reset offline cache</button>
    <button onclick="deleteAccount()">Delete account</button>
  </div>
</div>

<script>
// =================================== User interface

let account = null
if (typeof SANDBOX === 'undefined') {
  initView()
}

async function initView() {
  account = await readFromStorage('eth', 'account')
  if (account) {
    displayAccount()
  } else {
    document.querySelector('#initial').style.display = 'flex'
  }
}

async function generateSeed() {
  const canvas = document.querySelector('#generate_seed_canvas')
  const ctx = canvas.getContext('2d')

  function redraw() {
    const paddingV = fontSize
    const paddingH = fontSize
    const buttonPadding = canvas.height / 25
    const buttonH = (canvas.height - paddingH*2 - buttonPadding * 5) / 6
    const buttonW = (canvas.width - paddingV*2 - buttonPadding) / 2

    ctx.fillStyle = '#222'
    ctx.strokeStyle = 'bisque'
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    function drawWord(index, word, x, y) {
      let curX = x, curY = y, indexS = `${index}. `
      for (let curWord of [`${index}. `, word]) {
        for (let i = 0; i < curWord.length; i++) {
          const g = GLYPH.glyphs[curWord.charCodeAt(i)]
          ctx.drawImage(GLYPH.atlas, g.x, g.y, g.w, g.h, curX, curY, g.w / 2, g.h / 2)
          curX += fontSize * 0.55
        }
      }
    }
    for (let i = 0; i < mnemonicIndexes.length; i++) {
      let x = paddingV
      let y = paddingH + (buttonH + buttonPadding) * i
      if (i >= 6) {
        x = paddingV + buttonW + buttonPadding
        y = paddingH + (buttonH + buttonPadding) * (i - 6)
      }
      ctx.strokeRect(x, y, buttonW, buttonH)
      drawWord(i+1, biplist[mnemonicIndexes[i]], x + fontSize, y + buttonH / 2 - fontSize / 2)
    }
  }

  document.querySelector('#initial').style.display = 'none'
  document.querySelector('#generate_seed').style.display = 'flex'
  const nextBtn = document.querySelector('#generate_seed .next')
  nextBtn.onclick = async () => {
    document.querySelector('#generate_seed').style.display = 'none'
    document.querySelector('#enter_password').style.display = 'flex'
    const passwordData = await dispayPasswordInput(
      document.querySelector('#enter_password_canvas'),
      document.querySelector('#enter_password .next'), true)
    document.querySelector('#enter_password').style.display = 'none'
    account = await seedPhraseToAccount(indexesToMnemonicBuffer(mnemonicIndexes))
    const privKeyEncrypted = await encryptPrivkey(account.privKey, passwordData)
    await writeToStorage('eth', 'key_enc', privKeyEncrypted)
    await writeToStorage('eth', 'account', { address: account.address, qr: account.qr })
    account = await readFromStorage('eth', 'account')
    displayWalletLink()
  }
  const rect = canvas.getBoundingClientRect()
  canvas.width  = rect.width - 4
  canvas.height = rect.height
  const fontSize = canvas.width / 20
  const GLYPH = createGlyphAtlas(fontSize, 2)
  const mnemonicIndexes = await randomMnemonic()
  redraw()
  return
}

function deferred() { let resolve, reject, promise = new Promise((res, rej) => {resolve = res;reject = rej;}); return { promise, resolve, reject } }

async function dispayPasswordInput(canvas, nextBtn, confirmation) {
  async function redraw() {
    const layout = [
      ['1','2','3','4','5','6','7','8','9','0'],
      ['Q','W','E','R','T','Y','U','I','O','P'],
      ['A','S','D','F','G','H','J','K','L'],
      ['Z','X','C','V','B','N','M'],
      ['SPACE','←']]
    let passwordInvalidReason = null
    if (!prevPasswordInput && enteredSymbols < 5) {
      passwordInvalidReason = 'Enter at least 5 symbols'
    }
    if (prevPasswordInput && prevPasswordInput.length !== enteredSymbols) {
      passwordInvalidReason = 'Passwords not match'
    }
    if (prevPasswordInput && enteredSymbols === 0) {
      passwordInvalidReason = 'Enter again'
    }
    if (prevPasswordInput && prevPasswordInput.length === enteredSymbols) {
      for (var i = 0; i < enteredSymbols; i++) {
        if (prevPasswordInput[i] !== buffer[i]) {
          passwordInvalidReason = 'Passwords not match'
        }
      }
    }
    nextBtn.style.visibility = passwordInvalidReason ? 'hidden' : 'visible'

    ctx.fillStyle = '#222'
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    const kbTop = drawKeyboard(layout)
    if (passwordInvalidReason) {
      ctx.textBaseline = 'bottom'
      ctx.textAlign = 'left'
      ctx.fillStyle = 'bisque'
      ctx.fillText(passwordInvalidReason, 20, kbTop)
    }
    drawInput()
  }

  function drawInput() {
    const text = Array(enteredSymbols).fill('*').join('') + '_'
    ctx.strokeStyle = 'bisque'
    ctx.fillStyle = '#222'
    ctx.strokeRect(20, 60, canvas.width - 40, 50)
    ctx.textAlign = 'left'
    ctx.textBaseline = 'top'
    ctx.fillStyle = 'bisque'
    ctx.fillText('Enter password:', 20, 20)
    ctx.textBaseline = 'middle'
    ctx.fillText(text, 20 + 10, 60 + 50/2)
  }

  function resize() {
    canvas.width  = document.documentElement.clientWidth - 4
    canvas.height = 60 * 5 + 350
    redraw()
  }

  let prevPasswordInput = null
  async function handleKeyPress(key) {
    if (key.label === '←') { buffer[enteredSymbols--] = 0; enteredSymbols = Math.max(enteredSymbols, 0) }
    else { buffer[enteredSymbols] = key.code ^ salt[(enteredSymbols++) % salt.length] }
    redraw()
  }

  nextBtn.style.visibility = 'hidden'
  nextBtn.onclick = async () => {
    if (confirmation && !prevPasswordInput) {
      prevPasswordInput = buffer.slice(0, enteredSymbols)
      enteredSymbols = 0
      redraw()
      return
    }
    result.resolve({ buffer, enteredSymbols, salt })
  }
  const { drawKeyboard, ctx } = displayKeyboard(handleKeyPress, canvas)
  const fontSize = 24
  // store as buffer + xor key codes to hide password in memory
  const salt = new Uint8Array(Math.floor(Math.random() * 28) + 4)
  crypto.getRandomValues(salt)
  let buffer = new Uint8Array(256)
  let enteredSymbols = 0
  window.addEventListener('resize', resize)
  resize()
  const result = deferred()
  return result.promise
}

// to prevent leaking individual characters, using glyph atlas instead of ctx.fillText
function createGlyphAtlas(fontSize, scaleFactor=1) {
  let glyphSize = fontSize * scaleFactor
  const ABC = '0123456789abcdefghijklmnopqrstuvwxyz _.'
  const glyphs = new Array(256)
  const cols = 12, rows = 5
  const atlas = document.createElement('canvas')
  atlas.width  = cols * glyphSize
  atlas.height = rows * glyphSize
  const gctx = atlas.getContext('2d')
  gctx.fillStyle = 'rgba(0, 0, 0, 0)'
  gctx.fillRect(0, 0, atlas.width, atlas.height)
  gctx.fillStyle = 'bisque'
  gctx.font = `${glyphSize - 4}px monospace`
  gctx.textAlign = 'center'
  gctx.textBaseline = 'middle'
  for (let index = 0; index < ABC.length; index++) {
    const col = index % cols
    const row = Math.floor(index / cols)
    const x = col * glyphSize
    const y = row * glyphSize
    gctx.fillText(
      ABC[index],
      x + glyphSize / 2,
      y + glyphSize / 2
    )
    glyphs[ABC.charCodeAt(index)] = { x: x+1, y: y+1, w: glyphSize-2, h: glyphSize-2 }
  }
  return { atlas, glyphs, glyphSize }
}

async function displaySeedInput() {
  function displaySeedPhrase() {
    let curX = fontSize, curY = fontSize
    for (let i = 0; i <= enteredSymbols; i++) {
      const charCode = i === enteredSymbols ? 95 : buffer[i] ^ salt[i % salt.length]
      if (charCode === 32 && curX + fontSize * 5 > canvas.width) { curY += fontSize; curX = fontSize; continue }
      if (curX + 24 >= canvas.width) { curY += fontSize; curX = fontSize }
      const g = GLYPH.glyphs[charCode]
      ctx.drawImage(GLYPH.atlas, g.x, g.y, g.w, g.h, curX, curY, g.w, g.h)
      curX += fontSize / 2
    }
  }

  async function validateSeedPhrase() {
    let wordCount = 0
    let wordStart = 0
    let wordIndices = new Uint32Array(12)
    function getWordIndex(start, end) {
      let wordLen = end - start
      return biplist.findIndex(word => {
        if (word.length !== wordLen) return false
        for (let j = start; j < end; j++) {
          const char1 = buffer[j] ^ salt[j % salt.length]
          const char2 = word.charCodeAt(j - start)
          if (char1 !== char2) return false
        }
        return true
      })
    }
    for (let i = 0; i < enteredSymbols; i++) {
      const charCode = buffer[i] ^ salt[i % salt.length]
      const isLastWord = (i === enteredSymbols - 1 && wordCount === 11)
      if (charCode === 32 || isLastWord) {
        const wordIndex = getWordIndex(wordStart, isLastWord ? i + 1 : i)
        if (wordIndex === -1) {
          wordIndices.fill(0)
          return { valid: false, seedStatus: '❌ invalid word' }
        }
        wordIndices[Math.min(wordCount, 11)] = wordIndex
        wordStart = i + 1
        wordCount++
      }
    }
    if (wordCount !== 12) {
      wordIndices.fill(0)
      return { valid: false, seedStatus: `${wordCount}/12 words entered` }
    }
    if (await isValidMnemonic(wordIndices)) {
      wordIndices.fill(0)
      return { valid: true, seedStatus: '✅ 12 words correct, checksum valid' }
    }
    wordIndices.fill(0)
    return { valid: false, seedStatus: '❌ checksum invalid' }
  }

  let seedValid = false
  let seedStatus = ''
  async function handleKeyPress(key) {
    if (key.label === '←') { buffer[enteredSymbols--] = 0; enteredSymbols = Math.max(enteredSymbols, 0) }
    else { buffer[enteredSymbols] = key.code ^ salt[(enteredSymbols++) % salt.length] }
    const seedCheck = await validateSeedPhrase()
    seedValid = seedCheck.valid
    seedStatus = seedCheck.seedStatus
    redraw()
  }

  async function redraw() {
    const layout = [
      ['Q','W','E','R','T','Y','U','I','O','P'],
      ['A','S','D','F','G','H','J','K','L'],
      ['Z','X','C','V','B','N','M'],
      ['SPACE','←']]
    nextBtn.style.visibility = seedValid ? 'visible' : 'hidden'

    ctx.fillStyle = '#222'
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    const kbTop = drawKeyboard(layout)
    displaySeedPhrase()
    ctx.fillStyle = 'bisque'
    ctx.font = `${fontSize - 4}px monospace`
    ctx.textAlign = 'left'
    ctx.textBaseline = 'top'
    ctx.fillText(seedStatus, fontSize * 1.25, kbTop - 40)
  }

  function resize() {
    canvas.width  = document.documentElement.clientWidth - 4
    canvas.height = 60 * 5 + 200
    redraw()
  }

  document.querySelector('#initial').style.display = 'none'
  document.querySelector('#enter_seed').style.display = 'flex'
  const nextBtn = document.querySelector('#enter_seed .next')
  nextBtn.style.visibility = 'hidden'
  nextBtn.onclick = async () => {
    document.querySelector('#enter_seed').style.display = 'none'
    document.querySelector('#enter_password').style.display = 'flex'
    const passwordData = await dispayPasswordInput(
      document.getElementById('enter_password_canvas'),
      document.querySelector('#enter_password .next'), true)
    document.querySelector('#enter_password').style.display = 'none'

    account = await seedPhraseToAccount(decryptBuffer({ buffer, enteredSymbols, salt }))
    const privKeyEncrypted = await encryptPrivkey(account.privKey, passwordData)
    await writeToStorage('eth', 'key_enc', privKeyEncrypted)
    await writeToStorage('eth', 'account', { address: account.address, qr: account.qr })
    account = await readFromStorage('eth', 'account')
    displayWalletLink()
  }
  const { drawKeyboard, canvas, ctx } = displayKeyboard(handleKeyPress, document.getElementById('enter_seed_canvas'))
  const fontSize = 24
  const GLYPH = createGlyphAtlas(fontSize)
  // store as buffer + xor key codes to hide seed phrase in memory
  const salt = new Uint8Array(Math.floor(Math.random() * 28) + 4)
  crypto.getRandomValues(salt)
  let buffer = new Uint8Array(256)
  let enteredSymbols = 0
  const buf = (new TextEncoder()).encode('test test test test test test test test test test test input')
  while (enteredSymbols < buf.length) {
    buffer[enteredSymbols] = buf[enteredSymbols] ^ salt[(enteredSymbols++) % salt.length]
  }
  window.addEventListener('resize', resize)
  resize()
}

function displayKeyboard(onKey, canvas) {
  canvas.style.border = '2px solid bisque'
  canvas.style.margin = '20px -20px'
  const ctx = canvas.getContext('2d')

  let keys = []
  function drawKeyboard(layout) {
    const keyH = 60
    const padding = Math.floor(canvas.width * 0.01)
    const rows = layout.length
    const kbHeight = keyH * rows + padding * (rows + 1)
    const kbTop = canvas.height - kbHeight
    let y = kbTop + padding
    ctx.strokeStyle = 'bisque'
    ctx.lineWidth = 2
    ctx.fillStyle = 'bisque'
    ctx.font = `${Math.floor(keyH * 0.45)}px sans-serif`
    ctx.textAlign = 'center'
    ctx.textBaseline = 'middle'
    keys = []
    for (const row of layout) {
      let units = 0
      for (const key of row) {
        if (key === 'SPACE') units += 4
        else if (key === '←') units += 2
        else units += 1
      }
      const keyW = Math.floor((canvas.width - padding * (units + 1)) / units)
      let x = padding
      for (const label of row) {
        let w = keyW
        if (label === 'SPACE') w = keyW * 4
        if (label === '←') w = keyW * 2
        const key = { x, y, w, h: keyH, label, code: label === 'SPACE' ? 32 : label.toLowerCase().charCodeAt(0) }
        keys.push(key)
        ctx.strokeRect(key.x + 1, key.y + 1, key.w - 2, key.h - 2)
        ctx.fillText(key.label, key.x + key.w / 2, key.y + key.h / 2)
        x += w + padding
      }
      y += keyH + padding
    }
    return kbTop
  }

  async function handlePointer(e) {
    const rect = canvas.getBoundingClientRect()
    const x = (e.clientX - rect.left) / rect.width * canvas.width
    const y = (e.clientY - rect.top) / rect.height * canvas.height
    const key = keys.find((k) => x >= k.x && x <= k.x + k.w && y >= k.y && y <= k.y + k.h)
    if (key) {
      if (navigator.vibrate) { navigator.vibrate(20) }
      onKey(key)
    }
  }

  canvas.addEventListener('pointerdown', handlePointer)
  return { canvas, ctx, drawKeyboard }
}

function displayWalletLink(os='Android') {
  document.querySelector('#download_wallet').style.display = 'flex'
  const android = 'https://play.google.com/store/apps/details?id=com.debank.rabbymobile'
  const ios = 'https://apps.apple.com/us/app/rabby-wallet-crypto-evm/id6474381673'
  displayQR(document.querySelector("#download_wallet_link"), os === 'Android' ? android : ios, 'byte')

  document.querySelector('#download_wallet .next').onclick = () => {
    document.querySelector('#download_wallet').style.display = 'none'
    displayConnectWallet()
  }
}

function displayConnectWallet() {
  document.querySelector('#connect_wallet').style.display = 'flex'
  displayQR(document.getElementById("account_setup_qr"), account?.qr || '')

  document.querySelector('#connect_wallet .next').onclick = () => {
    document.querySelector('#connect_wallet').style.display = 'none'
    displayAccount()
  }
}

async function displayAccount() {
  const address = account.address
  window.account.style.display = 'block'
  window.account_addr.innerText = address.substring(0, 8) + '...' + address.substring(address.length - 6)
}
function triggerSettings() {
  if (window.account_actions.style.display === 'none') {
    window.account_actions.style.display = 'block'
    window.account_settings.style.display = 'none'
  } else {
    window.account_actions.style.display = 'none'
    window.account_settings.style.display = 'block'
    displayQR(document.getElementById("account_settings_qr"), account.qr || '')
  }
}

async function scanTransactionQR() {
  document.querySelector('#account').style.display = 'none'
  document.querySelector('#scan_transaction_qr').style.display = 'flex'
  const video = document.getElementById("qrcam")
  const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } }})
  video.srcObject = stream
  video.style.display = 'block'
  document.querySelector('#scan_transaction_qr .back').onclick = () => stream.getTracks().forEach(t => t.stop())
  
  const unsignedTx = await scanLoop(stream, video)

  stream.getTracks().forEach(t => t.stop())
  document.querySelector('#scan_transaction_qr').style.display = 'none'
  if (unsignedTx === 'aborted' || !unsignedTx) {
    document.querySelector('#account').style.display = 'flex'
    return
  }
  viewTransactionInfo(unsignedTx)
}

async function scanLoop(stream, video) {
  const canvas = document.getElementById("qrcanvas")
  let w = 0, h = 0, ctx = canvas.getContext('2d', { willReadFrequently: true })
  let fountainCodes = null
  while (stream.active && !stream.ended) {
    await new Promise(res => setTimeout(res, 50))
    if (video.videoWidth === 0 || video.videoHeight === 0) { continue }
    w = video.videoWidth, h = video.videoHeight
    if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h }
    ctx.drawImage(video, 0, 0, w, h)
    const qrimg = ctx.getImageData(0, 0, w, h)
    const result = qr.decodeQR(qrimg)
    if (!result) { continue }

    if (result.startsWith('UR:ETH-SIGN-REQUEST') && result.split('/').length === 2) {
      return decodeUR(result.split('/')[1].toLowerCase())
    } else if (result.startsWith('UR:ETH-SIGN-REQUEST') && result.split('/').length === 3) {
      if (!fountainCodes) { fountainCodes = fountainDecoder() }
      const { progress, message } = await fountainCodes(result)
      window.fountain_progress.value = Math.round(progress * 100)
      window.fountain_progress.style.display = 'block'
      if (progress === 1) {
        return message
      }
    } else {
      return null
    }
  }
  return 'aborted'
}

async function viewTransactionInfo(transaction) {
  const tx = decodeTranscation(transaction)
  if (tx.to && tx.data.length === 0) {
    window.tx_info.innerHTML = `Approve this transcation?<br/>
==========================<br/>
${tx.value}+(${tx.maxFee} fee) ETH -> ${tx.to}`
  } else if (tx.message) {
    window.tx_info.innerText = `⚠️ MESSAGE SIGNING (NOT A TRANSACTION)
This signature:
• DOES NOT send ETH
• DOES NOT approve tokens
• CAN be reused to authenticate you
• MAY grant access to accounts or services

Message to be signed:
==========================
${tx.message}
`
  } else {
    window.tx_info.innerText = `⚠️⚠️⚠️ Transaction could not be parsed:
It could be dangerous to sign.

Raw transaction(hex):
==========================
${bytesToHex(tx.signData)}
`
  }
  document.querySelector('#view_transaction').style.display = 'flex'
  document.querySelector('#view_transaction .next').onclick = () => {
    document.querySelector('#view_transaction').style.display = 'none'
    signTransaction(tx)
  }
}
async function signTransaction(tx) {
  let signedTx = null
  while(!signedTx) {
    document.querySelector('#sign_transaction').style.display = 'flex'
    const passwordData = await dispayPasswordInput(
      document.querySelector('#sign_transaction canvas'),
      document.querySelector('#sign_transaction .next'))
    document.querySelector('#sign_transaction').style.display = 'none'
    const privKeyEncrypted = await readFromStorage('eth', 'key_enc')
    const privKey = await decryptPrivkey(privKeyEncrypted, passwordData)
    if (privKey === null) {
      // TODO
      console.log('invalid password')
      continue
    }
    signedTx = await signEthRequest(tx, privKey)
  }

  document.querySelector('#signed_transaction_qr').style.display = 'flex'
  displayQR(document.querySelector("#qr_signed_tx"), 'UR:ETH-SIGNATURE/' + encodeUR(signedTx).toUpperCase())
  document.querySelector('#signed_transaction_qr .next').onclick = () => {
    document.querySelector('#signed_transaction_qr').style.display = 'none'
    document.querySelector('#account').style.display = 'flex'
  }
}

function displayQR(canvas, qrData, type='alphanumeric') {
  canvas.style.display = 'block'
  const qrBitmap = qr.encodeQR(qrData, type)
  const ctx = canvas.getContext("2d")
  ctx.imageSmoothingEnabled = false
  const moduleSize = Math.floor(canvas.width / qrBitmap.length)
  canvas.width = qrBitmap.length * moduleSize
  canvas.height = qrBitmap.length * moduleSize
  ctx.fillStyle = "#fff"
  ctx.fillRect(0, 0, canvas.width, canvas.height)
  ctx.fillStyle = "#000"
  for (let y = 0; y < qrBitmap.length; y++) {
    for (let x = 0; x < qrBitmap[y].length; x++) {
      if (qrBitmap[y][x]) ctx.fillRect(x * moduleSize, y * moduleSize, moduleSize, moduleSize)
    }
  }
}

async function deleteAccount() {
  const db = await openDB('eth')
  db.transaction('eth', 'readwrite').objectStore('eth').clear()
  location.reload()
}

// =================================== Mnemonic & keys functions

function decryptBuffer({ buffer, enteredSymbols, salt }) {
  const decryptedBuffer = new Uint8Array(enteredSymbols)
  for (let i = 0; i < decryptedBuffer.length; i++) {
    decryptedBuffer[i] = buffer[i] ^ salt[i % salt.length]
  }
  buffer.fill(0)
  salt.fill(0)
  return decryptedBuffer
}

async function encryptPrivkey(privKey, passwordData) {
  const salt = window.crypto.getRandomValues(new Uint8Array(16));
  const iv = window.crypto.getRandomValues(new Uint8Array(12));
  const password = decryptBuffer(passwordData)
  const baseKey = crypto.subtle.importKey("raw", password, "PBKDF2", false, ["deriveKey"]); password.fill(0)
  const aesKey = await crypto.subtle.deriveKey({ name: "PBKDF2", salt, iterations: 600000, hash: "SHA-512" },
    await baseKey, { name: "AES-GCM", length: 256 }, false, ["encrypt"])
  const privKeyBuf = numberToBytesBE(privKey, 32)
  const encSeed = crypto.subtle.encrypt({ name: "AES-GCM", iv }, aesKey, privKeyBuf); privKeyBuf.fill(0)
  return { encSeed: new Uint8Array(await encSeed), salt, iv }
}

async function decryptPrivkey({ encSeed, salt, iv }, passwordData) {
  const password = decryptBuffer(passwordData)
  const baseKey = crypto.subtle.importKey("raw", password, "PBKDF2", false, ["deriveKey"]); password.fill(0)
  const aesKey = await crypto.subtle.deriveKey({ name: "PBKDF2", salt, iterations: 600000, hash: "SHA-512" },
    await baseKey, { name: "AES-GCM", length: 256 }, false, ["decrypt"])
  try {
    const privKeyBuf = new Uint8Array(await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, aesKey, encSeed))
    const privKey = bytesToBigInt(privKeyBuf); privKeyBuf.fill(0)
    return privKey
  } catch(e) {
    return null
  }
}

function indexesToMnemonicBuffer(mnemonicIndexes) {
  const mnemonicBuffer = new Uint8Array(256)
  let mnemonicLen = 0
  for (let wordIndex of mnemonicIndexes) {
    if (mnemonicLen > 0) {
      mnemonicBuffer[mnemonicLen++] = 0x20
    }
    const word = biplist[wordIndex]
    for (let i = 0; i < word.length; i++) {
      mnemonicBuffer[mnemonicLen++] = word.charCodeAt(i)
    }
  }
  return mnemonicBuffer.subarray(0, mnemonicLen)
}

async function randomMnemonic() {
  const indexes = window.crypto.getRandomValues(new Uint32Array(12));
  for (let i = 0; i < indexes.length; i++) {
    indexes[i] = indexes[i] % 2048
  }
  indexes[11] = indexes[11] & 0xf0
  const entropyBytes = getEntropyBytes(indexes)
  const hash = new Uint8Array(await crypto.subtle.digest('SHA-256', entropyBytes.subarray(0, 16))); entropyBytes.fill(0);
  indexes[11] = indexes[11] | (hash[0] >> 4)
  return indexes
}

function getEntropyBytes(indexes) {
  const entropyBytes = new Uint8Array(33)
  let acc = 0, accBits = 0, j = 0;
  for (let i = 0; i < indexes.length; i++) {
    acc = (acc << 11) | indexes[i];
    accBits += 11;
    while (accBits >= 8) { accBits -= 8; entropyBytes[j++] = (acc >>> accBits) & 0xff; }
  }
  return entropyBytes
}

async function isValidMnemonic(indexes) {
  const entropyBytes = getEntropyBytes(indexes)
  if (indexes.length === 12) {
    const hash = new Uint8Array(await crypto.subtle.digest('SHA-256', entropyBytes.subarray(0, 16))); entropyBytes.fill(0);
    return (indexes[11] & 0x0f) === hash[0] >> 4;
  } else if (indexes.length === 24) {
    const hash = new Uint8Array(await crypto.subtle.digest('SHA-256', entropyBytes.subarray(0, 32))); entropyBytes.fill(0);
    return hash[0] === entropyBytes[32];
  } else if (indexes.length === 18) {
    const hash = new Uint8Array(await crypto.subtle.digest('SHA-256', entropyBytes.subarray(0, 24))); entropyBytes.fill(0);
    return (hash[0] >> 2) === (indexes[17] & 0x3f);
  } else if (indexes.length === 15) {
    const hash = new Uint8Array(await crypto.subtle.digest('SHA-256', entropyBytes.subarray(0, 20))); entropyBytes.fill(0);
    return ((hash[0] >> 3) & 0x1f) === (indexes[14] & 0x1f);
  }
  return false
}

async function seedPhraseToAccount(mnemonicBuffer) {
  const key = crypto.subtle.importKey("raw", mnemonicBuffer, { name: "PBKDF2" }, false, ["deriveBits"]); mnemonicBuffer.fill(0)
  const masterSeed = new Uint8Array(await crypto.subtle.deriveBits({ name: "PBKDF2", salt: new TextEncoder().encode("mnemonic"), iterations: 2048, hash: "SHA-512" }, await key, 512))
  let { privKey, accData } = await derivePath(masterSeed)
  const pubKey = getPublicKey(privKey, false) 
  const address = '0x'+bytesToHex(keccak256(pubKey.slice(1)).slice(12))
  const cbor = cborEncode({
    3: new Uint8Array(accData.pubkey),
    4: new Uint8Array(accData.chainCode),
    6: { tag: 0x130, value: { 1: [44, null, 60, null, 0, null], 2: await fingerprint(accData.pubkey) } },
    8: 0x66613465,
    9: `Signator - ${address.slice(0, 6)}`
  })
  return { qr: `UR:CRYPTO-HDKEY/${encodeUR(cbor)}`.toUpperCase(), privKey, address }
}

async function derivePath(seed, KEY_NUM=0) {
  const mcryptoKey = await crypto.subtle.importKey("raw", new TextEncoder().encode('Bitcoin seed'), { name: "HMAC", hash: "SHA-512" }, false, ["sign"])
  const masterSeed = crypto.subtle.sign("HMAC", mcryptoKey, seed); seed.fill(0)
  const master = new Uint8Array(await masterSeed)
  let privKey = bytesToBigInt(master.subarray(0, 32), 32)
  let chainCode = master.slice(32); master.fill(0)
  let data = new Uint8Array(37)
  async function derive(hardened, derivation) {
    if (hardened) {
      const privKeyBytes = numberToBytesBE(privKey, 32)
      data.set([0])
      data.set(privKeyBytes, 1); privKeyBytes.fill(0)
    } else {
      const pubKeyBytes = getPublicKey(privKey)
      data.set(pubKeyBytes); pubKeyBytes.fill(0)
    }
    data.set(derivation, 33)
    const cryptoKeyPromise = crypto.subtle.importKey("raw", chainCode, { name: "HMAC", hash: "SHA-512" }, false, ["sign"]); chainCode.fill(0)
    const I = crypto.subtle.sign("HMAC", await cryptoKeyPromise, data); data.fill(0)
    const signature = new Uint8Array(await I)
    privKey = (bytesToBigInt(signature.subarray(0, 32)) + privKey) % secp256k1_CURVE.n
    chainCode.set(signature.subarray(32))
    signature.fill(0)
  }
  await derive(true, [128, 0, 0, 44])
  await derive(true, [128, 0, 0, 60])
  await derive(true, [128, 0, 0, 0])
  const pubkey = getPublicKey(privKey)
  const chainCodeXpub = chainCode.slice()
  await derive(false, [0, 0, 0, 0])
  await derive(false, [0, 0, 0, KEY_NUM])
  return { privKey, accData: { pubkey, chainCode: chainCodeXpub } }
}

function getPublicKey(privKey, isCompressed=true) {
  const { X, Y } = secp256k1_mul(privKey)
  const x32b = numberToBytesBE(X, 32), y32b = numberToBytesBE(Y, 32)
  if (isCompressed) {
    const res = new Uint8Array(33)
    res.set((Y & 1n) === 0n ? [0x02] : [0x03])
    res.set(x32b, 1); x32b.fill(0)
    return res
  }
  const res = new Uint8Array(65)
  res.set([0x04])
  res.set(x32b, 1); x32b.fill(0)
  res.set(y32b, 33); y32b.fill(0)
  return res
};

async function fingerprint(pubkeyBytes) {
  var zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1,
      2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
  var zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9,
      11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11 ];
  var sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13,
      15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
  var sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6,
      14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e];
  var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000];
  function rotl(x, n) { return (x << n) | (x >>> (32 - n)); }
  function fn1(a, b, c, d, e, m, k, s) { return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0; }
  function fn2(a, b, c, d, e, m, k, s) { return (rotl((a + ((b & c) | (~b & d)) + m + k) | 0, s) + e) | 0; }
  function fn3(a, b, c, d, e, m, k, s) { return (rotl((a + ((b | ~c) ^ d) + m + k) | 0, s) + e) | 0; }
  function fn4(a, b, c, d, e, m, k, s) { return (rotl((a + ((b & d) | (c & ~d)) + m + k) | 0, s) + e) | 0; }
  function fn5(a, b, c, d, e, m, k, s) { return (rotl((a + (b ^ (c | ~d)) + m + k) | 0, s) + e) | 0; }

  const block = new Uint8Array(64)
  const words = new Uint32Array(block.buffer, block.byteOffset, block.byteLength / 4)
  block.set(new Uint8Array(await crypto.subtle.digest('SHA-256', new Uint8Array(pubkeyBytes))))
  words[8] = 0x80
  words[14] = 256
	var al = 0x67452301, ar = 0x67452301;
	var bl = 0xefcdab89, br = 0xefcdab89;
	var cl = 0x98badcfe, cr = 0x98badcfe;
	var dl = 0x10325476, dr = 0x10325476;
	var el = 0xc3d2e1f0, er = 0xc3d2e1f0;
	for (var i = 0; i < 80; i += 1) {
		var tl, tr;
		if (i < 16) {
			tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
			tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
		} else if (i < 32) {
			tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
			tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
		} else if (i < 48) {
			tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
			tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
		} else if (i < 64) {
			tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
			tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
		} else {
			tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
			tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
		}
		al = el; ar = er;
		el = dl; er = dr;
		dl = rotl(cl, 10); dr = rotl(cr, 10);
		cl = bl; cr = br;
		bl = tl; br = tr;
	}
	return revBytesU32((0xefcdab89 + cl + dr) | 0);
};

// ======================= CBOR + UR + fountain codecs

function cborEncode(data) {
  function encodeUint(n) {
      if (n < 24) return Uint8Array.of(n)
      if (n <= 0xff) return Uint8Array.of(0x18, n)
      if (n <= 0xffff) return concatBytes(Uint8Array.of(0x19, n >> 8, n & 0xff))
      if (n <= 0xffffffff) return concatBytes(Uint8Array.of(0x1a, (n >>> 24) & 0xff, (n >>> 16) & 0xff, (n >>> 8) & 0xff, n & 0xff))
      throw new Error("uint too big")
  }
  if (data === null) { return [0xf5] }
  if (typeof data === 'number') { return encodeUint(data) }
  if (typeof data === 'string') {
    const bytes = new TextEncoder().encode(data);
    if (bytes.length < 24) return concatBytes(Uint8Array.of(0x60 + bytes.length), bytes)
    return concatBytes(Uint8Array.of(0x78, bytes.length), bytes)
  }
  if (data.tag) {
    const tagB = encodeUint(data.tag)
    tagB[0] = 0xd9 // TODO
    return concatBytes(tagB, cborEncode(data.value))
  }
  if (data instanceof Uint8Array) {
    if (data.length < 24) return concatBytes(Uint8Array.of(0x40 + data.length), data)
    if (data.length <= 0xff) return concatBytes(Uint8Array.of(0x58, data.length), data)
    if (data.length <= 0xffff) return concatBytes(Uint8Array.of(0x59, data.length >> 8, data.length & 0xff), data)
    throw new Error("byte string too big")
  }
  if (Array.isArray(data)) {
    if (data.length < 24) { return concatBytes(Uint8Array.of(0x80 + data.length), ...data.map(x => cborEncode(x))) }
    throw new Error("array too big")
  }
  if (data.constructor === Object) {
    const out = [Uint8Array.of(0xa0 + Object.keys(data).length)]
    for (const k in data) out.push(cborEncode(parseInt(k, 10) || k), cborEncode(data[k]))
    return concatBytes(...out)
  }
  throw new Error(`unknown cbor object type ${data}`)
}

function cborDecode(bytes) {
  let pos = 0
  function decodeUint(n) {
    if (n < 0x18) return n
    if (n === 0x18) return bytes[pos++]
    if (n === 0x19) return ((bytes[pos++] << 8) | bytes[pos++]) >>> 0
    if (n === 0x1a) return ((bytes[pos++] << 24) | (bytes[pos++] << 16) | (bytes[pos++] << 8) | bytes[pos++]) >>> 0
    throw new Error(`Unsupported length ${n}`)
  }
  function decodeItem() {
    const b = bytes[pos++], major = b >> 5, n = b & 0x1f
    if (major === 0) return decodeUint(n)
    if (major === 2) { const len = decodeUint(n); return bytes.slice(pos, pos += len) }
    if (major === 3) { const len = decodeUint(n); return new TextDecoder('utf-8').decode(new Uint8Array(bytes.slice(pos, pos += len))) }
    if (major === 4) { const len = decodeUint(n), arr = []; for (let i = 0; i < len; i++) arr.push(decodeItem()); return arr }
    if (major === 5) { const len = decodeUint(n), obj = {}; for (let i = 0; i < len; i++) obj[decodeItem()] = decodeItem(); return obj }
    if (major === 6) { const tag = decodeUint(n); return decodeItem() }
    return null
  }
  return decodeItem()
}

function crc32(buf) {
  let crc = 0xffffffff
  for (let i = 0; i < buf.length; i++) {
    crc ^= buf[i]
    for (let j = 0; j < 8; j++) {
      crc = (crc >>> 1) ^ (0xEDB88320 & -(crc & 1))
    }
  }
  return (crc ^ 0xffffffff) >>> 0
}
const bytewords = 'ae,ad,ao,ax,aa,ah,am,at,ay,as,bk,bd,bn,bt,ba,bs,be,by,bg,bw,bb,bz,cm,ch,cs,cf,cy,cw,ce,ca,ck,\
ct,cx,cl,cp,cn,dk,da,ds,di,de,dt,dr,dn,dw,dp,dm,dl,dy,eh,ey,eo,ee,ec,en,em,et,es,ft,fr,fn,fs,fm,fh,fz,fp,fw,fx,fy,\
fe,fg,fl,fd,ga,ge,gr,gs,gt,gl,gw,gd,gy,gm,gu,gh,go,hf,hg,hd,hk,ht,hp,hh,hl,hy,he,hn,hs,id,ia,ie,ih,iy,io,is,in,im,\
je,jz,jn,jt,jl,jo,js,jp,jk,jy,kp,ko,kt,ks,kk,kn,kg,ke,ki,kb,lb,la,ly,lf,ls,lr,lp,ln,lt,lo,ld,le,lu,lk,lg,mn,my,mh,\
me,mo,mu,mw,md,mt,ms,mk,nl,ny,nd,ns,nt,nn,ne,nb,oy,oe,ot,ox,on,ol,os,pd,pt,pk,py,ps,pm,pl,pe,pf,pa,pr,qd,qz,re,rp,\
rl,ro,rh,rd,rk,rf,ry,rn,rs,rt,se,sa,sr,ss,sk,sw,st,sp,so,sg,sb,sf,sn,to,tk,ti,tt,td,te,ty,tl,tb,ts,tp,ta,tn,uy,uo,\
ut,ue,ur,vt,vy,vo,vl,ve,vw,va,vd,vs,wl,wd,wm,wp,we,wy,ws,wt,wn,wz,wf,wk,yk,yn,yl,ya,yt,zs,zo,zt,zc,ze,zm'.split(',')
function decodeUR(string) {
    return Array(string.length/2 - 4).fill(0).map((_, i) => bytewords.indexOf(string[i*2]+string[i*2+1]))
}
function encodeUR(data) {
    const crc = crc32(data)
    return data.concat([crc >>> 24, (crc >>> 16) & 0xff, (crc >>> 8) & 0xff, crc & 0xff]).map(w => bytewords[w]).join('')
}
async function Xoshiro256(seedBytes) {
    const MASK64 = (1n << 64n) - 1n
    const digest = new Uint8Array(await crypto.subtle.digest("SHA-256", new Uint8Array(seedBytes)));
    const s = []
    for (let i = 0; i < 4; i++) {
      let v = 0n
      for (let j = 0; j < 8; j++) v = (v << 8n) | BigInt(digest[i * 8 + j]);
      s.push(v & MASK64)
    }
    function roll() {
      const result = rotl((s[1] * 5n) & MASK64, 7) * 9n & MASK64;
      const t = (s[1] << 17n) & MASK64;
      s[2] ^= s[0]; s[3] ^= s[1]; s[1] ^= s[2];
      s[0] ^= s[3]; s[2] ^= t; s[3] = rotl(s[3], 45);
      return result;
    }
    function rotl(x, k) { return ((x << BigInt(k)) | (x >> (64n - BigInt(k)))) & MASK64; }
    function nextDouble() { return Number(roll()) / Number(MASK64 + 1n) }
    function nextInt(low, high) { return Math.floor(nextDouble() * (high - low + 1) + low) }
    return { s, nextDouble, nextInt}
}
async function chooseFragments(seqNum, seqLength, checksum) {
  function chooseDegree(seqLength, I, NG) {
    const p = new Array(seqLength);
    var sum = 0
    for (let i = 0; i < seqLength; i++) {
      p[i] = 1 / (i + 1);
      sum += p[i]
    }
    var scaledProbabilities = p.map(function (prob) { return (prob * seqLength) / sum; });
    var small = [];
    var large = [];
    for (var i = seqLength - 1; i >= 0; i--) {
        if (scaledProbabilities[i] < 1) { small.push(i) }
        else { large.push(i) }
    }
    let res = I
    while (small.length > 0 && large.length > 0) {
        var less = small.pop();
        var more = large.pop();
        if (less === I) { res = NG < scaledProbabilities[I] ? I : more; }
        if (more === I) { res = I }
        scaledProbabilities[more] += scaledProbabilities[less] - 1;
        if (scaledProbabilities[more] < 1) { small.push(more) }
        else { large.push(more) }
    }
    return res + 1
  }

  if (seqNum <= seqLength) {
    return [seqNum - 1];
  }
  const seed = intToBytes(seqNum).concat(intToBytes(checksum));
  const rng = await Xoshiro256(seed);
  const I = Math.floor(rng.nextDouble() * seqLength)
  const degree = chooseDegree(seqLength, I, rng.nextDouble());
  const indexes = new Array(seqLength);
  for (let i = 0; i < seqLength; i++) indexes[i] = i;
  let result = [];
  while (indexes.length > 0 && result.length < degree) {
      let index = rng.nextInt(0, indexes.length - 1);
      let item = indexes[index];
      indexes.splice(index, 1);
      result.push(item);
  }
  return result;
}

function fountainEncoder(message, PART_SIZE) {
  const crc = crc32(message)
  const messageParts = []
  let seqNum = 0
  const seqLength = Math.ceil(message.length / PART_SIZE)
  for (var p = 0; p < seqLength; p++) {
    let part = Array.from(message).slice(p * PART_SIZE, p * PART_SIZE + PART_SIZE)
    part = part.concat(Array(PART_SIZE - part.length).fill(0))
    messageParts.push(part)
  }
  return async function nextFragment() {
    const parts = await chooseFragments(++seqNum, messageParts.length, crc)
    const xored = messageParts[parts[0]].slice()
    for (var i = 1; i < parts.length; i++) {
      const part = messageParts[parts[i]]
      for (var j = 0; j < xored.length; j++) {
        xored[j] = xored[j] ^ part[j]
      }
    }
    const cbor = cborEncode([seqNum, seqLength, message.length, crc, new Uint8Array(xored)])
    return `ur:bytes/${seqNum}-${seqLength}/${encodeUR(cbor)}`
  }
}

function fountainDecoder() {
  function decodePass() {
    const newMixedFragments = []
    for (let i = 0; i < state.mixedFragments.length; i++) {
      const { parts, fragment } = state.mixedFragments[i]
      let newParts = [], newFragment = fragment.slice()
      for (let p = 0; p < parts.length; p++) {
        const part = state.decodedBlocks[parts[p]]
        if (part) {
          for (var j = 0; j < part.length; j++) {
            newFragment[j] = fragment[j] ^ part[j]
          }
        } else {
          newParts.push(parts[p])
        }
      }
      if (newParts.length === 1) { state.decodedBlocks[newParts[0]] = newFragment }
      if (newParts.length > 1) { newMixedFragments.push({ parts: newParts, fragment: newFragment }) }
    }
    const updated = newMixedFragments.length < state.mixedFragments
    state.mixedFragments = newMixedFragments
    return updated
  }
  const state = { decodedBlocks: {}, mixedFragments: [] }
  return async function nextPart(part) {
    const [seqNum, seqLength, messageLength, crc, fragment] = cborDecode(decodeUR(part.split('/')[2].toLowerCase()))
    const parts = await chooseFragments(seqNum, seqLength, crc)
    if (parts.length === 1) { state.decodedBlocks[parts[0]] = fragment }
    else { state.mixedFragments.push({ parts, fragment }) }
    while(decodePass()) {}
    const progress = Object.keys(state.decodedBlocks).length/seqLength
    if (progress === 1) {
      let message = []
      for (let i = 0; i < seqLength; i++) message = message.concat(state.decodedBlocks[i])
      return { progress: 1, message: message.slice(0, messageLength) }
    }
    return { progress, message: null }
  } 
}


// =================================== secp256k1 curve

var secp256k1_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
const M = (a, b = secp256k1_CURVE.p) => { const r = a % b; return r >= 0n ? r : b + r; };
const N = (a, b = secp256k1_CURVE.n) => { const r = a % b; return r >= 0n ? r : b + r; };
function secp256k1_add({ X: X1, Y: Y1, Z: Z1 }, { X: X2, Y: Y2, Z: Z2 }) {
    let X3 = 0n, Y3 = 0n, Z3 = 0n; let t0 = M(X1 * X2); let t1 = M(Y1 * Y2); let t2 = M(Z1 * Z2);
    let t3 = M(X1 + Y1); let t4 = M(X2 + Y2); let t5 = M(X2 + Z2); t3 = M(t3 * t4);
    t4 = M(t0 + t1); t3 = M(t3 - t4); t4 = M(X1 + Z1); t4 = M(t4 * t5); t5 = M(t0 + t2);
    t4 = M(t4 - t5); t5 = M(Y1 + Z1); X3 = M(Y2 + Z2); t5 = M(t5 * X3); X3 = M(t1 + t2);
    t5 = M(t5 - X3); t2 = M(21n * t2); X3 = M(t1 - t2); Z3 = M(t1 + t2); Y3 = M(X3 * Z3);
    t1 = M(t0 + t0); t1 = M(t1 + t0); t4 = M(21n * t4); t0 = M(t1 * t4); Y3 = M(Y3 + t0);
    t0 = M(t5 * t4); X3 = M(t3 * X3); X3 = M(X3 - t0); t0 = M(t3 * t1); Z3 = M(t5 * Z3);
    Z3 = M(Z3 + t0); return { X: X3, Y: Y3, Z: Z3 };
}
function secp256k1_mul(n) {
  let p = { X: 0n, Y: 1n, Z: 0n }
  let f = { X: secp256k1_CURVE.Gx, Y: secp256k1_CURVE.Gy, Z: 1n }
  for (let d = f; n > 0n; d = secp256k1_add(d, d), n >>= 1n) {
      if (n & 1n) p = secp256k1_add(p, d)
      else f = secp256k1_add(f, d) // fake point calc to negate side channel attack
  }
  const iz = invert(p.Z, secp256k1_CURVE.p)
  return { X: M(p.X * iz), Y: M(p.Y * iz) }
}
function invert(number, modulo) {
  let a = M(number, modulo), b = modulo, x = 0n, y = 1n, u = 1n, v = 0n;
  while (a !== 0n) {
    const q = b / a, r = b % a, m = x - u * q, n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  return M(x, modulo);
}

// =================================== Utils

function revBytesU32(n) { return (((n & 0xFF) << 24) | ((n & 0xFF00) << 8) | ((n & 0xFF0000) >>> 8)  |((n & 0xFF000000) >>> 24)) >>> 0 }
function intToBytes(i) { return [(i >>> 24) & 0xff, (i >>> 16) & 0xff, (i >>> 8) & 0xff, i & 0xff] }
function bytesToBigInt(b) { let r = 0n; for (let i = 0; i < b.length; i++) {r = (r << 8n) | BigInt(b[i])} return r }
function numberToHex(n, len) { return n.toString(16).padStart(len * 2, "0")}
function numberToBytesBE(n, len) { let x = BigInt(n); const out = new Uint8Array(len); for (let i = len - 1; i >= 0; i--) { out[i] = Number(x & 0xffn); x >>= 8n } return out }
function bytesToHex(u8arr) { return Array.from(u8arr).map(x => x.toString(16).padStart(2,'0')).join('') }
function bytesToFloat(bytes) { let n = 0; for (let i = 0; i < bytes.length; i++) n = n * 256 + bytes[i]; return n; }
function hexToBytes(s) { const b = []; for (let i = 0; i < s.length; i += 2) { b.push(parseInt(s.substr(i, 2), 16)) } return b }
function concatBytes(...arrays) {
  const res = new Array(arrays.reduce((sum, a) => sum + a.length, 0))
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    for (let j = 0; j < arrays[i].length; j++) {
      res[pad + j] = arrays[i][j]
    }
    pad += arrays[i].length
  }
  return res
}
async function openDB(storage) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('idb', 1)
    request.onupgradeneeded = (e) => { const db = e.target.result; if (!db.objectStoreNames.contains(storage)) db.createObjectStore(storage) }
    request.onsuccess = (event) => resolve(event.target.result)
    request.onerror = () => reject(request.error)
  })
}
async function writeToStorage(storage, key, data) {
  return new Promise(async (resolve, reject) => {
    const db = await openDB(storage)
    const putRequest = db.transaction(storage, "readwrite").objectStore(storage).put(data, key)
    putRequest.onsuccess = () => resolve(true)
    putRequest.onerror = () => reject(putRequest.error)
  })
}
async function readFromStorage(storage, key) {
  return new Promise(async (resolve, reject) => {
    const db = await openDB(storage)
    if (!db.objectStoreNames.contains(storage)) return resolve(undefined)
    const getRequest = db.transaction(storage, "readonly").objectStore(storage).get(key)
    getRequest.onsuccess = () => resolve(getRequest.result)
    getRequest.onerror = () => reject(getRequest.error)
  })
}

// =================================== transaction sign

async function signEthRequest({ id, signData, message }, privateKey) {
  if (message) {
    const prefix = (new TextEncoder()).encode("\x19Ethereum Signed Message:\n" + signData.length)
    signData = concatBytes(prefix, signData)
  }
  const digest = keccak256(signData)
  const m = N(bytesToBigInt(digest))
  const privKeyBytes = numberToBytesBE(privateKey, 32)
  const seed = new Uint8Array(64)
  seed.set(privKeyBytes); privKeyBytes.fill(0)
  seed.set(numberToBytesBE(m, 32), 32)
  let kk = await hmacSha256(new Uint8Array(32).fill(0), concatBytes(new Uint8Array(32).fill(1), Uint8Array.of(0), seed))
  let vv = await hmacSha256(kk, new Uint8Array(32).fill(1))
  kk = await hmacSha256(kk, concatBytes(vv, Uint8Array.of(1), seed)); seed.fill(0)
  vv = await hmacSha256(kk, vv)
  let k, r, s, q;
  while (true) {
    vv = await hmacSha256(kk, vv)
    k = bytesToBigInt(vv)
    if (k === 0n || k >= secp256k1_CURVE.n) {
      kk = await hmacSha256(kk, concatBytes(vv, Uint8Array.of(0)))
      vv = await hmacSha256(kk, vv)
      continue
    }
    kk = await hmacSha256(kk, concatBytes(vv, Uint8Array.of(0)))
    vv = await hmacSha256(kk, vv)
    q = secp256k1_mul(k)
    r = N(q.X); if (r === 0n) continue
    s = N(invert(k, secp256k1_CURVE.n) * N(m + r * privateKey)); if (s === 0n) continue
    break
  }
  let recovery = (q.X === r ? 0 : 2) | Number(q.Y & 1n)
  if (s > secp256k1_CURVE.n >> 1n) { s = secp256k1_CURVE.n - s; recovery ^= 1 }
  return concatBytes([0xa2, 0x01, 0xd8, 0x25, 0x50], id, [0x02, 0x58, 0x41], numberToBytesBE(r, 32), numberToBytesBE(s, 32), Uint8Array.of(recovery))
}

function keccak256(data) {
    const blockLen = 136
    const state = new Uint8Array(200)
    const state32 = new Uint32Array(state.buffer, state.byteOffset, Math.floor(state.byteLength / 4));
    const len = data.length
    let statePos = 0
    for (let pos = 0; pos < len;) {
        const take = Math.min(blockLen - statePos, len - pos)
        for (let i = 0; i < take; i++)
            state[statePos++] ^= data[pos++]
        if (statePos === blockLen) {
            keccak_block(state32)
            statePos = 0
        }
    }
    const out = new Uint8Array(32)
    state[statePos] ^= 0x01
    state[blockLen - 1] ^= 0x80
    keccak_block(state32)
    let posOut = 0
    for (let pos = 0, len = out.length; pos < len;) {
        if (posOut >= blockLen) { keccak_block(state32); posOut = 0 }
        const take = Math.min(blockLen - posOut, len - pos)
        out.set(state.subarray(posOut, posOut + take), pos)
        posOut += take
        pos += take
    }
    state.fill(0)
    return out
}
const SHA3_PI = [20, 14, 22, 34, 36, 6, 10, 32, 16, 42, 48, 8, 30, 46, 38, 26, 24, 4, 40, 28, 44, 18, 12, 2];
const SHA3_ROTL = [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 2, 14, 27, 41, 56, 8, 25, 43, 62, 18, 39, 61, 20, 44];
const SHA3_IOTA_H = [
             1,      32898,      32906, 2147516416,      32907, 2147483649,
    2147516545,      32777,        138,        136, 2147516425, 2147483658,
    2147516555,        139,      32905,      32771,      32770,        128,
         32778, 2147483658, 2147516545,      32896, 2147483649, 2147516424];
const SHA3_IOTA_L = [
             0,          0, 2147483648, 2147483648,          0,          0,
    2147483648, 2147483648,          0,          0,          0,          0,
             0, 2147483648, 2147483648, 2147483648, 2147483648, 2147483648,
             0, 2147483648, 2147483648, 2147483648,          0, 2147483648];
const rotlH = (h, l, s) => (s > 32 ? (l << (s - 32)) | (h >>> (64 - s)) : (h << s) | (l >>> (32 - s)));
const rotlL = (h, l, s) => (s > 32 ? (h << (s - 32)) | (l >>> (64 - s)) : (l << s) | (h >>> (32 - s)));
function keccak_block(s) {
    const B = new Uint32Array(5 * 2);
    for (let round = 0; round < 24; round++) {
        for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10
            const idx0 = (x + 2) % 10
            const B0 = B[idx0]
            const B1 = B[idx0 + 1]
            const Th = rotlH(B0, B1, 1) ^ B[idx1]
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1]
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th
                s[x + y + 1] ^= Tl
            }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t]
            const Th = rotlH(curH, curL, shift)
            const Tl = rotlL(curH, curL, shift)
            const PI = SHA3_PI[t]
            curH = s[PI]
            curL = s[PI + 1]
            s[PI] = Th
            s[PI + 1] = Tl
        }
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++) B[x] = s[y + x]
            for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10]
        }
        s[0] ^= SHA3_IOTA_H[round]
        s[1] ^= SHA3_IOTA_L[round]
    }
    B.fill(0)
}

async function hmacSha256(key, message) {
  const k = await crypto.subtle.importKey("raw", new Uint8Array(key), { name: "HMAC", hash: "SHA-256" }, false, ["sign"])
  return new Uint8Array(await crypto.subtle.sign("HMAC", k, new Uint8Array(message)))
}

// =================================== transaction decoder

function decodeTranscation(transactionCbor) {
  const decoded = cborDecode(transactionCbor)
  const id = decoded[1]
  const signData = decoded[2]
  function decodeRLP(buf, offset) {
    const prefix = buf[offset];
    if (prefix <= 0x7f) {
      return { value: buf.slice(offset, offset + 1), next: offset + 1 };
    }
    if (prefix <= 0xb7) {
      const len = prefix - 0x80;
      const start = offset + 1;
      return {
        value: buf.slice(start, start + len),
        next: start + len
      };
    }
    if (prefix <= 0xbf) {
      const lenLen = prefix - 0xb7;
      let len = 0;
      for (let i = 0; i < lenLen; i++) {
        len = (len << 8) + buf[offset + 1 + i];
      }
      const start = offset + 1 + lenLen;
      return {
        value: buf.slice(start, start + len),
        next: start + len
      };
    }
    if (prefix <= 0xf7) {
      const len = prefix - 0xc0;
      let pos = offset + 1;
      const end = pos + len;
      const items = [];
      while (pos < end) {
        const decoded = decodeRLP(buf, pos);
        items.push(decoded.value);
        pos = decoded.next;
      }
      return { value: items, next: end };
    }
    const lenLen = prefix - 0xf7;
    let len = 0;
    for (let i = 0; i < lenLen; i++) {
      len = (len << 8) + buf[offset + 1 + i];
    }
    let pos = offset + 1 + lenLen;
    const end = pos + len;
    const items = [];
    while (pos < end) {
      const decoded = decodeRLP(buf, pos);
      items.push(decoded.value);
      pos = decoded.next;
    }
    return { value: items, next: end };
  }
  if (signData[0] !== 0x02 && signData[0] !== 0x01 && signData[0] < 0xc0) { // probably plain message
    return { message: new TextDecoder().decode(new Uint8Array(signData)) }
  }
  const fields = decodeRLP(signData, 1).value
  return {
    id,
    signData,
    data: fields[7],
    chainId: bytesToFloat(fields[0]),
    to: '0x'+bytesToHex(fields[5]),
    value: bytesToFloat(fields[6]) / 1e18,
    maxFee: bytesToFloat(fields[4]) * bytesToFloat(fields[3]) / 1e18,
  };
}

// =================================== QR codecs, Copyright (c) 2023 Paul Miller (paulmillr.com), https://github.com/paulmillr/qr

var qr = (() => {
  var chCodes = { newline: 10, reset: 27 };
  function assertNumber(n) {
    if (!Number.isSafeInteger(n))
      throw new Error(`integer expected: ${n}`);
  }
  function validateVersion(ver) {
    if (!Number.isSafeInteger(ver) || ver < 1 || ver > 40)
      throw new Error(`Invalid version=${ver}. Expected number [1..40]`);
  }
  function bin(dec, pad) {
    return dec.toString(2).padStart(pad, "0");
  }
  function mod(a, b) {
    const result = a % b;
    return result >= 0 ? result : b + result;
  }
  function fillArr(length, val) {
    return new Array(length).fill(val);
  }
  function interleaveBytes(...blocks) {
    let len = 0;
    for (const b of blocks)
      len = Math.max(len, b.length);
    const res = [];
    for (let i = 0; i < len; i++) {
      for (const b of blocks) {
        if (i >= b.length)
          continue;
        res.push(b[i]);
      }
    }
    return new Uint8Array(res);
  }
  function includesAt(lst, pattern2, index) {
    if (index < 0 || index + pattern2.length > lst.length)
      return false;
    for (let i = 0; i < pattern2.length; i++)
      if (pattern2[i] !== lst[index + i])
        return false;
    return true;
  }
  function best() {
    let best3;
    let bestScore = Infinity;
    return {
      add(score, value) {
        if (score >= bestScore)
          return;
        best3 = value;
        bestScore = score;
      },
      get: () => best3,
      score: () => bestScore
    };
  }
  function alphabet(alphabet2) {
    return {
      has: (char) => alphabet2.includes(char),
      decode: (input) => {
        if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
          throw new Error("alphabet.decode input should be array of strings");
        return input.map((letter) => {
          if (typeof letter !== "string")
            throw new Error(`alphabet.decode: not string element=${letter}`);
          const index = alphabet2.indexOf(letter);
          if (index === -1)
            throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
          return index;
        });
      },
      encode: (digits) => {
        if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
          throw new Error("alphabet.encode input should be an array of numbers");
        return digits.map((i) => {
          assertNumber(i);
          if (i < 0 || i >= alphabet2.length)
            throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet2.length})`);
          return alphabet2[i];
        });
      }
    };
  }
  var Bitmap = class _Bitmap {
    static size(size, limit) {
      if (typeof size === "number")
        size = { height: size, width: size };
      if (!Number.isSafeInteger(size.height) && size.height !== Infinity)
        throw new Error(`Bitmap: invalid height=${size.height} (${typeof size.height})`);
      if (!Number.isSafeInteger(size.width) && size.width !== Infinity)
        throw new Error(`Bitmap: invalid width=${size.width} (${typeof size.width})`);
      if (limit !== void 0) {
        size = {
          width: Math.min(size.width, limit.width),
          height: Math.min(size.height, limit.height)
        };
      }
      return size;
    }
    static fromString(s) {
      s = s.replace(/^\n+/g, "").replace(/\n+$/g, "");
      const lines = s.split(String.fromCharCode(chCodes.newline));
      const height = lines.length;
      const data = new Array(height);
      let width;
      for (const line of lines) {
        const row = line.split("").map((i) => {
          if (i === "X")
            return true;
          if (i === " ")
            return false;
          if (i === "?")
            return void 0;
          throw new Error(`Bitmap.fromString: unknown symbol=${i}`);
        });
        if (width && row.length !== width)
          throw new Error(`Bitmap.fromString different row sizes: width=${width} cur=${row.length}`);
        width = row.length;
        data.push(row);
      }
      if (!width)
        width = 0;
      return new _Bitmap({ height, width }, data);
    }
    data;
    height;
    width;
    constructor(size, data) {
      const { height, width } = _Bitmap.size(size);
      this.data = data || Array.from({ length: height }, () => fillArr(width, void 0));
      this.height = height;
      this.width = width;
    }
    point(p) {
      return this.data[p.y][p.x];
    }
    isInside(p) {
      return 0 <= p.x && p.x < this.width && 0 <= p.y && p.y < this.height;
    }
    size(offset) {
      if (!offset)
        return { height: this.height, width: this.width };
      const { x, y } = this.xy(offset);
      return { height: this.height - y, width: this.width - x };
    }
    xy(c) {
      if (typeof c === "number")
        c = { x: c, y: c };
      if (!Number.isSafeInteger(c.x))
        throw new Error(`Bitmap: invalid x=${c.x}`);
      if (!Number.isSafeInteger(c.y))
        throw new Error(`Bitmap: invalid y=${c.y}`);
      c.x = mod(c.x, this.width);
      c.y = mod(c.y, this.height);
      return c;
    }
    // Basically every operation can be represented as rect
    rect(c, size, value) {
      const { x, y } = this.xy(c);
      const { height, width } = _Bitmap.size(size, this.size({ x, y }));
      for (let yPos = 0; yPos < height; yPos++) {
        for (let xPos = 0; xPos < width; xPos++) {
          this.data[y + yPos][x + xPos] = typeof value === "function" ? value({ x: xPos, y: yPos }, this.data[y + yPos][x + xPos]) : value;
        }
      }
      return this;
    }
    // returns rectangular part of bitmap
    rectRead(c, size, fn) {
      return this.rect(c, size, (c2, cur) => {
        fn(c2, cur);
        return cur;
      });
    }
    // Horizontal & vertical lines
    hLine(c, len, value) {
      return this.rect(c, { width: len, height: 1 }, value);
    }
    vLine(c, len, value) {
      return this.rect(c, { width: 1, height: len }, value);
    }
    // add border
    border(border = 2, value) {
      const height = this.height + 2 * border;
      const width = this.width + 2 * border;
      const v = fillArr(border, value);
      const h = Array.from({ length: border }, () => fillArr(width, value));
      return new _Bitmap({ height, width }, [...h, ...this.data.map((i) => [...v, ...i, ...v]), ...h]);
    }
    // Embed another bitmap on coordinates
    embed(c, bm) {
      return this.rect(c, bm.size(), ({ x, y }) => bm.data[y][x]);
    }
    // returns rectangular part of bitmap
    rectSlice(c, size = this.size()) {
      const rect = new _Bitmap(_Bitmap.size(size, this.size(this.xy(c))));
      this.rect(c, size, ({ x, y }, cur) => rect.data[y][x] = cur);
      return rect;
    }
    // Change shape, replace rows with columns (data[y][x] -> data[x][y])
    inverse() {
      const { height, width } = this;
      const res = new _Bitmap({ height: width, width: height });
      return res.rect({ x: 0, y: 0 }, Infinity, ({ x, y }) => this.data[x][y]);
    }
    // Each pixel size is multiplied by factor
    scale(factor) {
      if (!Number.isSafeInteger(factor) || factor > 1024)
        throw new Error(`invalid scale factor: ${factor}`);
      const { height, width } = this;
      const res = new _Bitmap({ height: factor * height, width: factor * width });
      return res.rect({ x: 0, y: 0 }, Infinity, ({ x, y }) => this.data[Math.floor(y / factor)][Math.floor(x / factor)]);
    }
    clone() {
      const res = new _Bitmap(this.size());
      return res.rect({ x: 0, y: 0 }, this.size(), ({ x, y }) => this.data[y][x]);
    }
    // Ensure that there is no undefined values left
    assertDrawn() {
      this.rectRead(0, Infinity, (_, cur) => {
        if (typeof cur !== "boolean")
          throw new Error(`Invalid color type=${typeof cur}`);
      });
    }
    // Simple string representation for debugging
    toString() {
      return this.data.map((i) => i.map((j) => j === void 0 ? "?" : j ? "X" : " ").join("")).join(String.fromCharCode(chCodes.newline));
    }
    toImage(isRGB = false) {
      const { height, width } = this.size();
      const data = new Uint8Array(height * width * (isRGB ? 3 : 4));
      let i = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const value = !!this.data[y][x] ? 0 : 255;
          data[i++] = value;
          data[i++] = value;
          data[i++] = value;
          if (!isRGB)
            data[i++] = 255;
        }
      }
      return { height, width, data };
    }
  };
  var ECMode = ["low", "medium", "quartile", "high"];
  var Encoding = ["numeric", "alphanumeric", "byte", "kanji", "eci"];
  var BYTES = [
    // 1,  2,  3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,   20,
    26,
    44,
    70,
    100,
    134,
    172,
    196,
    242,
    292,
    346,
    404,
    466,
    532,
    581,
    655,
    733,
    815,
    901,
    991,
    1085,
    //  21,   22,   23,   24,   25,   26,   27,   28,   29,   30,   31,   32,   33,   34,   35,   36,   37,   38,   39,   40
    1156,
    1258,
    1364,
    1474,
    1588,
    1706,
    1828,
    1921,
    2051,
    2185,
    2323,
    2465,
    2611,
    2761,
    2876,
    3034,
    3196,
    3362,
    3532,
    3706
  ];
  var WORDS_PER_BLOCK = {
    // Version 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40
    low: [7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    medium: [10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
    quartile: [13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    high: [17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
  };
  var ECC_BLOCKS = {
    // Version   1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40
    low: [1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
    medium: [1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
    quartile: [1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
    high: [1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
  };
  var info = {
    size: {
      encode: (ver) => 21 + 4 * (ver - 1),
      // ver1 = 21, ver40=177 blocks
      decode: (size) => (size - 17) / 4
    },
    sizeType: (ver) => Math.floor((ver + 7) / 17),
    // Based on https://codereview.stackexchange.com/questions/74925/algorithm-to-generate-this-alignment-pattern-locations-table-for-qr-codes
    alignmentPatterns(ver) {
      if (ver === 1)
        return [];
      const first = 6;
      const last = info.size.encode(ver) - first - 1;
      const distance3 = last - first;
      const count = Math.ceil(distance3 / 28);
      let interval = Math.floor(distance3 / count);
      if (interval % 2)
        interval += 1;
      else if (distance3 % count * 2 >= count)
        interval += 2;
      const res = [first];
      for (let m = 1; m < count; m++)
        res.push(last - (count - m) * interval);
      res.push(last);
      return res;
    },
    ECCode: {
      low: 1,
      medium: 0,
      quartile: 3,
      high: 2
    },
    formatMask: 21522,
    formatBits(ecc, maskIdx) {
      const data = info.ECCode[ecc] << 3 | maskIdx;
      let d = data;
      for (let i = 0; i < 10; i++)
        d = d << 1 ^ (d >> 9) * 1335;
      return (data << 10 | d) ^ info.formatMask;
    },
    versionBits(ver) {
      let d = ver;
      for (let i = 0; i < 12; i++)
        d = d << 1 ^ (d >> 11) * 7973;
      return ver << 12 | d;
    },
    alphabet: {
      numeric: alphabet("0123456789"),
      alphanumerc: alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:")
    },
    // as Record<EncodingType, ReturnType<typeof alphabet>>,
    lengthBits(ver, type) {
      const table = {
        numeric: [10, 12, 14],
        alphanumeric: [9, 11, 13],
        byte: [8, 16, 16],
        kanji: [8, 10, 12],
        eci: [0, 0, 0]
      };
      return table[type][info.sizeType(ver)];
    },
    modeBits: {
      numeric: "0001",
      alphanumeric: "0010",
      byte: "0100",
      kanji: "1000",
      eci: "0111"
    },
    capacity(ver, ecc) {
      const bytes = BYTES[ver - 1];
      const words = WORDS_PER_BLOCK[ecc][ver - 1];
      const numBlocks = ECC_BLOCKS[ecc][ver - 1];
      const blockLen = Math.floor(bytes / numBlocks) - words;
      const shortBlocks = numBlocks - bytes % numBlocks;
      return {
        words,
        numBlocks,
        shortBlocks,
        blockLen,
        capacity: (bytes - words * numBlocks) * 8,
        total: (words + blockLen) * numBlocks + numBlocks - shortBlocks
      };
    }
  };
  var PATTERNS = [
    (x, y) => (x + y) % 2 == 0,
    (_x, y) => y % 2 == 0,
    (x, _y) => x % 3 == 0,
    (x, y) => (x + y) % 3 == 0,
    (x, y) => (Math.floor(y / 2) + Math.floor(x / 3)) % 2 == 0,
    (x, y) => x * y % 2 + x * y % 3 == 0,
    (x, y) => (x * y % 2 + x * y % 3) % 2 == 0,
    (x, y) => ((x + y) % 2 + x * y % 3) % 2 == 0
  ];
  var GF = {
    tables: ((p_poly) => {
      const exp = fillArr(256, 0);
      const log = fillArr(256, 0);
      for (let i = 0, x = 1; i < 256; i++) {
        exp[i] = x;
        log[x] = i;
        x <<= 1;
        if (x & 256)
          x ^= p_poly;
      }
      return { exp, log };
    })(285),
    exp: (x) => GF.tables.exp[x],
    log(x) {
      if (x === 0)
        throw new Error(`GF.log: invalid arg=${x}`);
      return GF.tables.log[x] % 255;
    },
    mul(x, y) {
      if (x === 0 || y === 0)
        return 0;
      return GF.tables.exp[(GF.tables.log[x] + GF.tables.log[y]) % 255];
    },
    add: (x, y) => x ^ y,
    pow: (x, e) => GF.tables.exp[GF.tables.log[x] * e % 255],
    inv(x) {
      if (x === 0)
        throw new Error(`GF.inverse: invalid arg=${x}`);
      return GF.tables.exp[255 - GF.tables.log[x]];
    },
    polynomial(poly) {
      if (poly.length == 0)
        throw new Error("GF.polymomial: invalid length");
      if (poly[0] !== 0)
        return poly;
      let i = 0;
      for (; i < poly.length - 1 && poly[i] == 0; i++)
        ;
      return poly.slice(i);
    },
    monomial(degree, coefficient) {
      if (degree < 0)
        throw new Error(`GF.monomial: invalid degree=${degree}`);
      if (coefficient == 0)
        return [0];
      let coefficients = fillArr(degree + 1, 0);
      coefficients[0] = coefficient;
      return GF.polynomial(coefficients);
    },
    degree: (a) => a.length - 1,
    coefficient: (a, degree) => a[GF.degree(a) - degree],
    mulPoly(a, b) {
      if (a[0] === 0 || b[0] === 0)
        return [0];
      const res = fillArr(a.length + b.length - 1, 0);
      for (let i = 0; i < a.length; i++) {
        for (let j = 0; j < b.length; j++) {
          res[i + j] = GF.add(res[i + j], GF.mul(a[i], b[j]));
        }
      }
      return GF.polynomial(res);
    },
    mulPolyScalar(a, scalar) {
      if (scalar == 0)
        return [0];
      if (scalar == 1)
        return a;
      const res = fillArr(a.length, 0);
      for (let i = 0; i < a.length; i++)
        res[i] = GF.mul(a[i], scalar);
      return GF.polynomial(res);
    },
    mulPolyMonomial(a, degree, coefficient) {
      if (degree < 0)
        throw new Error("GF.mulPolyMonomial: invalid degree");
      if (coefficient == 0)
        return [0];
      const res = fillArr(a.length + degree, 0);
      for (let i = 0; i < a.length; i++)
        res[i] = GF.mul(a[i], coefficient);
      return GF.polynomial(res);
    },
    addPoly(a, b) {
      if (a[0] === 0)
        return b;
      if (b[0] === 0)
        return a;
      let smaller = a;
      let larger = b;
      if (smaller.length > larger.length)
        [smaller, larger] = [larger, smaller];
      let sumDiff = fillArr(larger.length, 0);
      let lengthDiff = larger.length - smaller.length;
      let s = larger.slice(0, lengthDiff);
      for (let i = 0; i < s.length; i++)
        sumDiff[i] = s[i];
      for (let i = lengthDiff; i < larger.length; i++)
        sumDiff[i] = GF.add(smaller[i - lengthDiff], larger[i]);
      return GF.polynomial(sumDiff);
    },
    remainderPoly(data, divisor) {
      const out = Array.from(data);
      for (let i = 0; i < data.length - divisor.length + 1; i++) {
        const elm = out[i];
        if (elm === 0)
          continue;
        for (let j = 1; j < divisor.length; j++) {
          if (divisor[j] !== 0)
            out[i + j] = GF.add(out[i + j], GF.mul(divisor[j], elm));
        }
      }
      return out.slice(data.length - divisor.length + 1, out.length);
    },
    divisorPoly(degree) {
      let g = [1];
      for (let i = 0; i < degree; i++)
        g = GF.mulPoly(g, [1, GF.pow(2, i)]);
      return g;
    },
    evalPoly(poly, a) {
      if (a == 0)
        return GF.coefficient(poly, 0);
      let res = poly[0];
      for (let i = 1; i < poly.length; i++)
        res = GF.add(GF.mul(a, res), poly[i]);
      return res;
    },
    // TODO: cleanup
    euclidian(a, b, R) {
      if (GF.degree(a) < GF.degree(b))
        [a, b] = [b, a];
      let rLast = a;
      let r = b;
      let tLast = [0];
      let t = [1];
      while (2 * GF.degree(r) >= R) {
        let rLastLast = rLast;
        let tLastLast = tLast;
        rLast = r;
        tLast = t;
        if (rLast[0] === 0)
          throw new Error("rLast[0] === 0");
        r = rLastLast;
        let q = [0];
        const dltInverse = GF.inv(rLast[0]);
        while (GF.degree(r) >= GF.degree(rLast) && r[0] !== 0) {
          const degreeDiff = GF.degree(r) - GF.degree(rLast);
          const scale = GF.mul(r[0], dltInverse);
          q = GF.addPoly(q, GF.monomial(degreeDiff, scale));
          r = GF.addPoly(r, GF.mulPolyMonomial(rLast, degreeDiff, scale));
        }
        q = GF.mulPoly(q, tLast);
        t = GF.addPoly(q, tLastLast);
        if (GF.degree(r) >= GF.degree(rLast))
          throw new Error(`Division failed r: ${r}, rLast: ${rLast}`);
      }
      const sigmaTildeAtZero = GF.coefficient(t, 0);
      if (sigmaTildeAtZero == 0)
        throw new Error("sigmaTilde(0) was zero");
      const inverse = GF.inv(sigmaTildeAtZero);
      return [GF.mulPolyScalar(t, inverse), GF.mulPolyScalar(r, inverse)];
    }
  };
  function RS(eccWords) {
    return {
      encode(from) {
        const d = GF.divisorPoly(eccWords);
        const pol = Array.from(from);
        pol.push(...d.slice(0, -1).fill(0));
        return Uint8Array.from(GF.remainderPoly(pol, d));
      },
      decode(to) {
        const res = to.slice();
        const poly = GF.polynomial(Array.from(to));
        let syndrome = fillArr(eccWords, 0);
        let hasError = false;
        for (let i = 0; i < eccWords; i++) {
          const evl = GF.evalPoly(poly, GF.exp(i));
          syndrome[syndrome.length - 1 - i] = evl;
          if (evl !== 0)
            hasError = true;
        }
        if (!hasError)
          return res;
        syndrome = GF.polynomial(syndrome);
        const monomial = GF.monomial(eccWords, 1);
        const [errorLocator, errorEvaluator] = GF.euclidian(monomial, syndrome, eccWords);
        const locations = fillArr(GF.degree(errorLocator), 0);
        let e = 0;
        for (let i = 1; i < 256 && e < locations.length; i++) {
          if (GF.evalPoly(errorLocator, i) === 0)
            locations[e++] = GF.inv(i);
        }
        if (e !== locations.length)
          throw new Error("RS.decode: invalid errors number");
        for (let i = 0; i < locations.length; i++) {
          const pos = res.length - 1 - GF.log(locations[i]);
          if (pos < 0)
            throw new Error("RS.decode: invalid error location");
          const xiInverse = GF.inv(locations[i]);
          let denominator = 1;
          for (let j = 0; j < locations.length; j++) {
            if (i === j)
              continue;
            denominator = GF.mul(denominator, GF.add(1, GF.mul(locations[j], xiInverse)));
          }
          res[pos] = GF.add(res[pos], GF.mul(GF.evalPoly(errorEvaluator, xiInverse), GF.inv(denominator)));
        }
        return res;
      }
    };
  }
  function interleave(ver, ecc) {
    const { words, shortBlocks, numBlocks, blockLen, total } = info.capacity(ver, ecc);
    const rs = RS(words);
    return {
      encode(bytes) {
        const blocks = [];
        const eccBlocks = [];
        for (let i = 0; i < numBlocks; i++) {
          const isShort = i < shortBlocks;
          const len = blockLen + (isShort ? 0 : 1);
          blocks.push(bytes.subarray(0, len));
          eccBlocks.push(rs.encode(bytes.subarray(0, len)));
          bytes = bytes.subarray(len);
        }
        const resBlocks = interleaveBytes(...blocks);
        const resECC = interleaveBytes(...eccBlocks);
        const res = new Uint8Array(resBlocks.length + resECC.length);
        res.set(resBlocks);
        res.set(resECC, resBlocks.length);
        return res;
      },
      decode(data) {
        if (data.length !== total)
          throw new Error(`interleave.decode: len(data)=${data.length}, total=${total}`);
        const blocks = [];
        for (let i = 0; i < numBlocks; i++) {
          const isShort = i < shortBlocks;
          blocks.push(new Uint8Array(words + blockLen + (isShort ? 0 : 1)));
        }
        let pos = 0;
        for (let i = 0; i < blockLen; i++) {
          for (let j = 0; j < numBlocks; j++)
            blocks[j][i] = data[pos++];
        }
        for (let j = shortBlocks; j < numBlocks; j++)
          blocks[j][blockLen] = data[pos++];
        for (let i = blockLen; i < blockLen + words; i++) {
          for (let j = 0; j < numBlocks; j++) {
            const isShort = j < shortBlocks;
            blocks[j][i + (isShort ? 0 : 1)] = data[pos++];
          }
        }
        const res = [];
        for (const block of blocks)
          res.push(...Array.from(rs.decode(block)).slice(0, -words));
        return Uint8Array.from(res);
      }
    };
  }
  function drawTemplate(ver, ecc, maskIdx, test = false) {
    const size = info.size.encode(ver);
    let b = new Bitmap(size + 2);
    const finder = new Bitmap(3).rect(0, 3, true).border(1, false).border(1, true).border(1, false);
    b = b.embed(0, finder).embed({ x: -finder.width, y: 0 }, finder).embed({ x: 0, y: -finder.height }, finder);
    b = b.rectSlice(1, size);
    const align = new Bitmap(1).rect(0, 1, true).border(1, false).border(1, true);
    const alignPos = info.alignmentPatterns(ver);
    for (const y of alignPos) {
      for (const x of alignPos) {
        if (b.data[y][x] !== void 0)
          continue;
        b.embed({ x: x - 2, y: y - 2 }, align);
      }
    }
    b = b.hLine({ x: 0, y: 6 }, Infinity, ({ x }, cur) => cur === void 0 ? x % 2 == 0 : cur).vLine({ x: 6, y: 0 }, Infinity, ({ y }, cur) => cur === void 0 ? y % 2 == 0 : cur);
    {
      const bits = info.formatBits(ecc, maskIdx);
      const getBit = (i) => !test && (bits >> i & 1) == 1;
      for (let i = 0; i < 6; i++)
        b.data[i][8] = getBit(i);
      for (let i = 6; i < 8; i++)
        b.data[i + 1][8] = getBit(i);
      for (let i = 8; i < 15; i++)
        b.data[size - 15 + i][8] = getBit(i);
      for (let i = 0; i < 8; i++)
        b.data[8][size - i - 1] = getBit(i);
      for (let i = 8; i < 9; i++)
        b.data[8][15 - i - 1 + 1] = getBit(i);
      for (let i = 9; i < 15; i++)
        b.data[8][15 - i - 1] = getBit(i);
      b.data[size - 8][8] = !test;
    }
    if (ver >= 7) {
      const bits = info.versionBits(ver);
      for (let i = 0; i < 18; i += 1) {
        const bit = !test && (bits >> i & 1) == 1;
        const x = Math.floor(i / 3);
        const y = i % 3 + size - 8 - 3;
        b.data[x][y] = bit;
        b.data[y][x] = bit;
      }
    }
    return b;
  }
  function zigzag(tpl, maskIdx, fn) {
    const size = tpl.height;
    const pattern2 = PATTERNS[maskIdx];
    let dir = -1;
    let y = size - 1;
    for (let xOffset = size - 1; xOffset > 0; xOffset -= 2) {
      if (xOffset == 6)
        xOffset = 5;
      for (; ; y += dir) {
        for (let j = 0; j < 2; j += 1) {
          const x = xOffset - j;
          if (tpl.data[y][x] !== void 0)
            continue;
          fn(x, y, pattern2(x, y));
        }
        if (y + dir < 0 || y + dir >= size)
          break;
      }
      dir = -dir;
    }
  }
  function encode(ver, ecc, data, type) {
    let encoded = '';
    let dataLen = data.length;
    if (type === 'alphanumeric') {
      const t = info.alphabet.alphanumerc.decode(data.split(''));
      const n = t.length;
      for (let i = 0; i < n - 1; i += 2) encoded += bin(t[i] * 45 + t[i + 1], 11);
      if (n % 2 == 1) encoded += bin(t[n - 1], 6);
    } else if (type === 'byte') {
      const utf8 = new TextEncoder().encode(data);
      dataLen = utf8.length;
      encoded = Array.from(utf8).map((i) => bin(i, 8)).join('');
    } else { throw new Error('encode: unsupported type'); }
    const { capacity } = info.capacity(ver, ecc);
    const len = bin(dataLen, info.lengthBits(ver, type));
    let bits = info.modeBits[type] + len + encoded;
    if (bits.length > capacity) throw new Error('Capacity overflow');
    bits += '0'.repeat(Math.min(4, Math.max(0, capacity - bits.length)));
    if (bits.length % 8) bits += '0'.repeat(8 - (bits.length % 8));
    const padding = '1110110000010001';
    for (let idx = 0; bits.length !== capacity; idx++) bits += padding[idx % padding.length];
    const bytes = Uint8Array.from(bits.match(/(.{8})/g).map((i) => Number(`0b${i}`)));
    return interleave(ver, ecc).encode(bytes);
  }
  function drawQR(ver, ecc, data, maskIdx, test = false) {
    const b = drawTemplate(ver, ecc, maskIdx, test);
    let i = 0;
    const need = 8 * data.length;
    zigzag(b, maskIdx, (x, y, mask) => {
      let value = false;
      if (i < need) {
        value = (data[i >>> 3] >> (7 - i & 7) & 1) !== 0;
        i++;
      }
      b.data[y][x] = value !== mask;
    });
    if (i !== need)
      throw new Error("QR: bytes left after draw");
    return b;
  }
  function penalty(bm) {
    const inverse = bm.inverse();
    const sameColor = (row) => {
      let res = 0;
      for (let i = 0, same = 1, last = void 0; i < row.length; i++) {
        if (last === row[i]) {
          same++;
          if (i !== row.length - 1)
            continue;
        }
        if (same >= 5)
          res += 3 + (same - 5);
        last = row[i];
        same = 1;
      }
      return res;
    };
    let adjacent = 0;
    bm.data.forEach((row) => adjacent += sameColor(row));
    inverse.data.forEach((column) => adjacent += sameColor(column));
    let box = 0;
    let b = bm.data;
    const lastW = bm.width - 1;
    const lastH = bm.height - 1;
    for (let x = 0; x < lastW; x++) {
      for (let y = 0; y < lastH; y++) {
        const x1 = x + 1;
        const y1 = y + 1;
        if (b[x][y] === b[x1][y] && b[x1][y] === b[x][y1] && b[x1][y] === b[x1][y1]) {
          box += 3;
        }
      }
    }
    const finderPattern = (row) => {
      const finderPattern2 = [true, false, true, true, true, false, true];
      const lightPattern = [false, false, false, false];
      const p1 = [...finderPattern2, ...lightPattern];
      const p2 = [...lightPattern, ...finderPattern2];
      let res = 0;
      for (let i = 0; i < row.length; i++) {
        if (includesAt(row, p1, i))
          res += 40;
        if (includesAt(row, p2, i))
          res += 40;
      }
      return res;
    };
    let finder = 0;
    for (const row of bm.data)
      finder += finderPattern(row);
    for (const column of inverse.data)
      finder += finderPattern(column);
    let darkPixels = 0;
    bm.rectRead(0, Infinity, (_c, val) => darkPixels += val ? 1 : 0);
    const darkPercent = darkPixels / (bm.height * bm.width) * 100;
    const dark = 10 * Math.floor(Math.abs(darkPercent - 50) / 5);
    return adjacent + box + finder + dark;
  }
  function drawQRBest(ver, ecc, data, maskIdx) {
    if (maskIdx === void 0) {
      const bestMask = best();
      for (let mask = 0; mask < PATTERNS.length; mask++)
        bestMask.add(penalty(drawQR(ver, ecc, data, mask, true)), mask);
      maskIdx = bestMask.get();
    }
    if (maskIdx === void 0)
      throw new Error("Cannot find mask");
    return drawQR(ver, ecc, data, maskIdx);
  }
  function encodeQR(text, type='alphanumeric') {
    const ecc = "medium"
    let ver = undefined;
    let data, err = new Error("Unknown error");
    for (let i = 1; i <= 40; i++) {
      try {
        data = encode(i, ecc, text, type);
        ver = i;
        break;
      } catch (e) {
        err = e;
      }
    }
    if (!ver || !data)
      throw err;
    let res = drawQRBest(ver, ecc, data);
    res.assertDrawn();
    res = res.border(2, false);
    return res.data;
  }

  // ../../decode.js
  var MAX_BITS_ERROR = 3;
  var GRAYSCALE_BLOCK_SIZE = 8;
  var GRAYSCALE_RANGE = 24;
  var PATTERN_VARIANCE = 2;
  var PATTERN_VARIANCE_DIAGONAL = 1.333;
  var PATTERN_MIN_CONFIRMATIONS = 2;
  var DETECT_MIN_ROW_SKIP = 3;
  var int = (n) => n >>> 0;
  var distance2 = (p1, p2) => {
    const x = p1.x - p2.x;
    const y = p1.y - p2.y;
    return x * x + y * y;
  };
  var distance = (p1, p2) => Math.sqrt(distance2(p1, p2));
  var sum = (lst) => lst.reduce((acc, i) => acc + i);
  var pointIncr = (p, incr) => {
    p.x += incr.x;
    p.y += incr.y;
  };
  var pointNeg = (p) => ({ x: -p.x, y: -p.y });
  var pointMirror = (p) => ({ x: p.y, y: p.x });
  var pointClone = (p) => ({ x: p.x, y: p.y });
  var pointInt = (p) => ({ x: int(p.x), y: int(p.y) });
  function cap(value, min, max) {
    return Math.max(Math.min(value, max || value), min || value);
  }
  var getBytesPerPixel = (img) => {
    const perPixel = img.data.length / (img.width * img.height);
    if (perPixel === 3 || perPixel === 4)
      return perPixel;
    throw new Error(`Unknown image format, bytes per pixel=${perPixel}`);
  };
  function toBitmap(img) {
    const bytesPerPixel = getBytesPerPixel(img);
    const brightness = new Uint8Array(img.height * img.width);
    for (let i = 0, j = 0, d = img.data; i < d.length; i += bytesPerPixel) {
      const r = d[i];
      const g = d[i + 1];
      const b = d[i + 2];
      brightness[j++] = int((r + 2 * g + b) / 4) & 255;
    }
    const block = GRAYSCALE_BLOCK_SIZE;
    if (img.width < block * 5 || img.height < block * 5)
      throw new Error("image too small");
    const bWidth = Math.ceil(img.width / block);
    const bHeight = Math.ceil(img.height / block);
    const maxY = img.height - block;
    const maxX = img.width - block;
    const blocks = new Uint8Array(bWidth * bHeight);
    for (let y = 0; y < bHeight; y++) {
      const yPos = cap(y * block, 0, maxY);
      for (let x = 0; x < bWidth; x++) {
        const xPos = cap(x * block, 0, maxX);
        let sum2 = 0;
        let min = 255;
        let max = 0;
        for (let yy = 0, pos = yPos * img.width + xPos; yy < block; yy = yy + 1, pos = pos + img.width) {
          for (let xx = 0; xx < block; xx++) {
            const pixel = brightness[pos + xx];
            sum2 += pixel;
            min = Math.min(min, pixel);
            max = Math.max(max, pixel);
          }
        }
        let average = Math.floor(sum2 / block ** 2);
        if (max - min <= GRAYSCALE_RANGE) {
          average = min / 2;
          if (y > 0 && x > 0) {
            const idx = (x2, y2) => y2 * bWidth + x2;
            const prev = (blocks[idx(x, y - 1)] + 2 * blocks[idx(x - 1, y)] + blocks[idx(x - 1, y - 1)]) / 4;
            if (min < prev)
              average = prev;
          }
        }
        blocks[bWidth * y + x] = int(average);
      }
    }
    const matrix = new Bitmap({ width: img.width, height: img.height });
    for (let y = 0; y < bHeight; y++) {
      const yPos = cap(y * block, 0, maxY);
      const top = cap(y, 2, bHeight - 3);
      for (let x = 0; x < bWidth; x++) {
        const xPos = cap(x * block, 0, maxX);
        const left = cap(x, 2, bWidth - 3);
        let sum2 = 0;
        for (let yy = -2; yy <= 2; yy++) {
          const y2 = bWidth * (top + yy) + left;
          for (let xx = -2; xx <= 2; xx++)
            sum2 += blocks[y2 + xx];
        }
        const average = sum2 / 25;
        for (let y2 = 0, pos = yPos * img.width + xPos; y2 < block; y2 += 1, pos += img.width) {
          for (let x2 = 0; x2 < block; x2++) {
            if (brightness[pos + x2] <= average)
              matrix.data[yPos + y2][xPos + x2] = true;
          }
        }
      }
    }
    return matrix;
  }
  function patternEquals(p, p2) {
    if (Math.abs(p2.y - p.y) <= p2.moduleSize && Math.abs(p2.x - p.x) <= p2.moduleSize) {
      const diff = Math.abs(p2.moduleSize - p.moduleSize);
      return diff <= 1 || diff <= p.moduleSize;
    }
    return false;
  }
  function patternMerge(a, b) {
    const count = a.count + b.count;
    return {
      x: (a.count * a.x + b.count * b.x) / count,
      y: (a.count * a.y + b.count * b.y) / count,
      moduleSize: (a.count * a.moduleSize + b.count * b.moduleSize) / count,
      count
    };
  }
  var patternsConfirmed = (lst) => lst.filter((i) => i.count >= PATTERN_MIN_CONFIRMATIONS);
  function pattern(p, size) {
    const _size = size || fillArr(p.length, 1);
    if (p.length !== _size.length)
      throw new Error("invalid pattern");
    if (!(p.length & 1))
      throw new Error("invalid pattern, length should be odd");
    const res = {
      center: Math.ceil(p.length / 2) - 1,
      length: p.length,
      pattern: p,
      size: _size,
      runs: () => fillArr(p.length, 0),
      totalSize: sum(_size),
      total: (runs) => runs.reduce((acc, i) => acc + i),
      shift: (runs, n) => {
        for (let i = 0; i < runs.length - n; i++)
          runs[i] = runs[i + 2];
        for (let i = runs.length - n; i < runs.length; i++)
          runs[i] = 0;
      },
      checkSize(runs, moduleSize, v = PATTERN_VARIANCE) {
        const variance = moduleSize / v;
        for (let i = 0; i < runs.length; i++) {
          if (Math.abs(_size[i] * moduleSize - runs[i]) >= _size[i] * variance)
            return false;
        }
        return true;
      },
      add(out, x, y, total) {
        const moduleSize = total / FINDER.totalSize;
        const cur = { x, y, moduleSize, count: 1 };
        for (let idx = 0; idx < out.length; idx++) {
          const f = out[idx];
          if (!patternEquals(f, cur))
            continue;
          return out[idx] = patternMerge(f, cur);
        }
        out.push(cur);
        return;
      },
      toCenter(runs, end) {
        for (let i = p.length - 1; i > res.center; i--)
          end -= runs[i];
        end -= runs[res.center] / 2;
        return end;
      },
      check(b, runs, center, incr, maxCount) {
        let j = 0;
        let i = pointClone(center);
        const neg = pointNeg(incr);
        const check = (p2, step) => {
          for (; b.isInside(i) && !!b.point(i) === res.pattern[p2]; pointIncr(i, step)) {
            runs[p2]++;
            j++;
          }
          if (runs[p2] === 0)
            return true;
          const center2 = p2 === res.center;
          if (maxCount && !center2 && runs[p2] > res.size[p2] * maxCount)
            return true;
          return false;
        };
        for (let p2 = res.center; p2 >= 0; p2--)
          if (check(p2, neg))
            return false;
        i = pointClone(center);
        pointIncr(i, incr);
        j = 1;
        for (let p2 = res.center; p2 < res.length; p2++)
          if (check(p2, incr))
            return false;
        return j;
      },
      scanLine(b, y, xStart, xEnd, fn) {
        const runs = res.runs();
        let pos = 0;
        let x = xStart;
        if (xStart)
          while (x < xEnd && !!b.data[y][x] === res.pattern[0])
            x++;
        for (; x < xEnd; x++) {
          if (!!b.data[y][x] === res.pattern[pos]) {
            runs[pos]++;
            if (x !== b.width - 1)
              continue;
            x++;
          }
          if (pos !== res.length - 1) {
            runs[++pos]++;
            continue;
          }
          const found = fn(runs, x);
          if (found) {
            pos = 0;
            runs.fill(0);
          } else if (found === false) {
            break;
          } else {
            res.shift(runs, 2);
            pos = res.length - 2;
            runs[pos]++;
          }
        }
      }
    };
    return res;
  }
  var FINDER = pattern([true, false, true, false, true], [1, 1, 3, 1, 1]);
  var ALIGNMENT = pattern([false, true, false]);
  function findFinder(b) {
    let found = [];
    function checkRuns(runs, v = 2) {
      const total = sum(runs);
      if (total < FINDER.totalSize)
        return false;
      const moduleSize = total / FINDER.totalSize;
      return FINDER.checkSize(runs, moduleSize, v);
    }
    function checkLine(center, maxCount, total, incr) {
      const runs = FINDER.runs();
      let i = FINDER.check(b, runs, center, incr, maxCount);
      if (i === false)
        return false;
      const runsTotal = sum(runs);
      if (5 * Math.abs(runsTotal - total) >= 2 * total)
        return false;
      if (checkRuns(runs))
        return FINDER.toCenter(runs, i);
      return false;
    }
    function check(runs, i, j) {
      if (!checkRuns(runs))
        return false;
      const total = sum(runs);
      let x = FINDER.toCenter(runs, j);
      let y = checkLine({ x: int(x), y: i }, runs[2], total, { y: 1, x: 0 });
      if (y === false)
        return false;
      y += i;
      let xx = checkLine({ x: int(x), y: int(y) }, runs[2], total, { y: 0, x: 1 });
      if (xx === false)
        return false;
      x = xx + int(x);
      const dRuns = FINDER.runs();
      if (!FINDER.check(b, dRuns, { x: int(x), y: int(y) }, { x: 1, y: 1 }))
        return false;
      if (!checkRuns(dRuns, PATTERN_VARIANCE_DIAGONAL))
        return false;
      FINDER.add(found, x, y, total);
      return true;
    }
    let skipped = false;
    let ySkip = cap(int(3 * b.height / (4 * 97)), DETECT_MIN_ROW_SKIP);
    let done = false;
    for (let y = ySkip - 1; y < b.height && !done; y += ySkip) {
      FINDER.scanLine(b, y, 0, b.width, (runs, x) => {
        if (!check(runs, y, x))
          return;
        ySkip = 2;
        if (skipped) {
          let count = 0;
          let total = 0;
          for (const p3 of found) {
            if (p3.count < PATTERN_MIN_CONFIRMATIONS)
              continue;
            count++;
            total += p3.moduleSize;
          }
          if (count < 3)
            return;
          const average = total / found.length;
          let deviation = 0;
          for (const p3 of found)
            deviation += Math.abs(p3.moduleSize - average);
          if (deviation <= 0.05 * total) {
            done = true;
            return false;
          }
        } else if (found.length > 1) {
          const q = patternsConfirmed(found);
          if (q.length < 2)
            return true;
          skipped = true;
          const d = int((Math.abs(q[0].x - q[1].x) - Math.abs(q[0].y - q[1].y)) / 2);
          if (d <= runs[2] + ySkip)
            return true;
          y += d - runs[2] - ySkip;
          return false;
        }
        return;
      });
    }
    const flen = found.length;
    if (flen < 3)
      throw new Error(`Finder: len(found) = ${flen}`);
    found.sort((i, j) => i.moduleSize - j.moduleSize);
    const pBest = best();
    for (let i = 0; i < flen - 2; i++) {
      const fi = found[i];
      for (let j = i + 1; j < flen - 1; j++) {
        const fj = found[j];
        const square0 = distance2(fi, fj);
        for (let k = j + 1; k < flen; k++) {
          const fk = found[k];
          if (fk.moduleSize > fi.moduleSize * 1.4)
            continue;
          const arr = [square0, distance2(fj, fk), distance2(fi, fk)].sort((a2, b3) => a2 - b3);
          const a = arr[0];
          const b2 = arr[1];
          const c = arr[2];
          pBest.add(Math.abs(c - 2 * b2) + Math.abs(c - 2 * a), [fi, fj, fk]);
        }
      }
    }
    const p = pBest.get();
    if (!p)
      throw new Error("cannot find finder");
    const p0 = p[0];
    const p1 = p[1];
    const p2 = p[2];
    const d01 = distance(p0, p1);
    const d12 = distance(p1, p2);
    const d02 = distance(p0, p2);
    let tl = p2;
    let bl = p0;
    let tr = p1;
    if (d12 >= d01 && d12 >= d02) {
      tl = p0;
      bl = p1;
      tr = p2;
    } else if (d02 >= d12 && d02 >= d01) {
      tl = p1;
      bl = p0;
      tr = p2;
    }
    if ((tr.x - tl.x) * (bl.y - tl.y) - (tr.y - tl.y) * (bl.x - tl.x) < 0) {
      let _bl = bl;
      bl = tr;
      tr = _bl;
    }
    return { bl, tl, tr };
  }
  function findAlignment(b, est, allowanceFactor) {
    const { moduleSize } = est;
    const allowance = int(allowanceFactor * moduleSize);
    const leftX = cap(est.x - allowance, 0);
    const rightX = cap(est.x + allowance, void 0, b.width - 1);
    const x = rightX - leftX;
    const topY = cap(est.y - allowance, 0);
    const bottomY = cap(est.y + allowance, void 0, b.height - 1);
    const y = bottomY - topY;
    if (x < moduleSize * 3 || y < moduleSize * 3)
      throw new Error(`x = ${x}, y=${y} moduleSize = ${moduleSize}`);
    const xStart = leftX;
    const yStart = topY;
    const width = rightX - leftX;
    const height = bottomY - topY;
    const found = [];
    const xEnd = xStart + width;
    const middleY = int(yStart + height / 2);
    for (let yGen = 0; yGen < height; yGen++) {
      const diff = int((yGen + 1) / 2);
      const y2 = middleY + (yGen & 1 ? -diff : diff);
      let res;
      ALIGNMENT.scanLine(b, y2, xStart, xEnd, (runs, x2) => {
        if (!ALIGNMENT.checkSize(runs, moduleSize))
          return;
        const total = sum(runs);
        const xx = ALIGNMENT.toCenter(runs, x2);
        const rVert = ALIGNMENT.runs();
        let v = ALIGNMENT.check(b, rVert, { x: int(xx), y: y2 }, { y: 1, x: 0 }, 2 * runs[1]);
        if (v === false)
          return;
        v += y2;
        const vTotal = sum(rVert);
        if (5 * Math.abs(vTotal - total) >= 2 * total)
          return;
        if (!ALIGNMENT.checkSize(rVert, moduleSize))
          return;
        const yy = ALIGNMENT.toCenter(rVert, v);
        res = ALIGNMENT.add(found, xx, yy, total);
        if (res)
          return false;
        return;
      });
      if (res)
        return res;
    }
    if (found.length > 0)
      return found[0];
    throw new Error("Alignment pattern not found");
  }
  function _single(b, from, to) {
    let steep = false;
    let d = { x: Math.abs(to.x - from.x), y: Math.abs(to.y - from.y) };
    if (d.y > d.x) {
      steep = true;
      from = pointMirror(from);
      to = pointMirror(to);
      d = pointMirror(d);
    }
    let error = -d.x / 2;
    let step = { x: from.x >= to.x ? -1 : 1, y: from.y >= to.y ? -1 : 1 };
    let runPos = 0;
    let xLimit = to.x + step.x;
    for (let x = from.x, y = from.y; x !== xLimit; x += step.x) {
      let real = { x, y };
      if (steep)
        real = pointMirror(real);
      if (runPos === 1 === !!b.point(real)) {
        if (runPos === 2)
          return distance({ x, y }, from);
        runPos++;
      }
      error += d.y;
      if (error <= 0)
        continue;
      if (y === to.y)
        break;
      y += step.y;
      error -= d.x;
    }
    if (runPos === 2)
      return distance({ x: to.x + step.x, y: to.y }, from);
    return NaN;
  }
  function BWBRunLength(b, from, to) {
    let result = _single(b, from, to);
    let scaleY = 1;
    const { x: fx, y: fy } = from;
    let otherToX = fx - (to.x - fx);
    const bw = b.width;
    if (otherToX < 0) {
      scaleY = fx / (fx - otherToX);
      otherToX = 0;
    } else if (otherToX >= bw) {
      scaleY = (bw - 1 - fx) / (otherToX - fx);
      otherToX = bw - 1;
    }
    let otherToY = int(fy - (to.y - fy) * scaleY);
    let scaleX = 1;
    const bh = b.height;
    if (otherToY < 0) {
      scaleX = fy / (fy - otherToY);
      otherToY = 0;
    } else if (otherToY >= bh) {
      scaleX = (bh - 1 - fy) / (otherToY - fy);
      otherToY = bh - 1;
    }
    otherToX = int(fx + (otherToX - fx) * scaleX);
    result += _single(b, from, { x: otherToX, y: otherToY });
    return result - 1;
  }
  function moduleSizeAvg(b, p1, p2) {
    const est1 = BWBRunLength(b, pointInt(p1), pointInt(p2));
    const est2 = BWBRunLength(b, pointInt(p2), pointInt(p1));
    if (Number.isNaN(est1))
      return est2 / FINDER.totalSize;
    if (Number.isNaN(est2))
      return est1 / FINDER.totalSize;
    return (est1 + est2) / (2 * FINDER.totalSize);
  }
  function detect(b) {
    const { bl, tl, tr } = findFinder(b);
    const moduleSize = (moduleSizeAvg(b, tl, tr) + moduleSizeAvg(b, tl, bl)) / 2;
    if (moduleSize < 1)
      throw new Error(`invalid moduleSize = ${moduleSize}`);
    const tltr = int(distance(tl, tr) / moduleSize + 0.5);
    const tlbl = int(distance(tl, bl) / moduleSize + 0.5);
    let size = int((tltr + tlbl) / 2 + 7);
    const rem = size % 4;
    if (rem === 0)
      size++;
    else if (rem === 2)
      size--;
    else if (rem === 3)
      size -= 2;
    const version = info.size.decode(size);
    validateVersion(version);
    let alignmentPattern;
    if (info.alignmentPatterns(version).length > 0) {
      const br2 = { x: tr.x - tl.x + bl.x, y: tr.y - tl.y + bl.y };
      const c = 1 - 3 / (info.size.encode(version) - 7);
      const est = {
        x: int(tl.x + c * (br2.x - tl.x)),
        y: int(tl.y + c * (br2.y - tl.y)),
        moduleSize,
        count: 1
      };
      for (let i = 4; i <= 16; i <<= 1) {
        try {
          alignmentPattern = findAlignment(b, est, i);
          break;
        } catch (e) {
        }
      }
    }
    const toTL = { x: 3.5, y: 3.5 };
    const toTR = { x: size - 3.5, y: 3.5 };
    const toBL = { x: 3.5, y: size - 3.5 };
    let br;
    let toBR;
    if (alignmentPattern) {
      br = alignmentPattern;
      toBR = { x: size - 6.5, y: size - 6.5 };
    } else {
      br = { x: tr.x - tl.x + bl.x, y: tr.y - tl.y + bl.y };
      toBR = { x: size - 3.5, y: size - 3.5 };
    }
    const from = [tl, tr, br, bl];
    const bits = transform(b, size, from, [toTL, toTR, toBR, toBL]);
    return { bits, points: from };
  }
  function squareToQuadrilateral(p) {
    const d3 = { x: p[0].x - p[1].x + p[2].x - p[3].x, y: p[0].y - p[1].y + p[2].y - p[3].y };
    if (d3.x === 0 && d3.y === 0) {
      return [
        [p[1].x - p[0].x, p[2].x - p[1].x, p[0].x],
        [p[1].y - p[0].y, p[2].y - p[1].y, p[0].y],
        [0, 0, 1]
      ];
    } else {
      const d1 = { x: p[1].x - p[2].x, y: p[1].y - p[2].y };
      const d2 = { x: p[3].x - p[2].x, y: p[3].y - p[2].y };
      const den = d1.x * d2.y - d2.x * d1.y;
      const p13 = (d3.x * d2.y - d2.x * d3.y) / den;
      const p23 = (d1.x * d3.y - d3.x * d1.y) / den;
      return [
        [p[1].x - p[0].x + p13 * p[1].x, p[3].x - p[0].x + p23 * p[3].x, p[0].x],
        [p[1].y - p[0].y + p13 * p[1].y, p[3].y - p[0].y + p23 * p[3].y, p[0].y],
        [p13, p23, 1]
      ];
    }
  }
  function transform(b, size, from, to) {
    const p = squareToQuadrilateral(to);
    const qToS = [
      [
        p[1][1] * p[2][2] - p[2][1] * p[1][2],
        p[2][1] * p[0][2] - p[0][1] * p[2][2],
        p[0][1] * p[1][2] - p[1][1] * p[0][2]
      ],
      [
        p[2][0] * p[1][2] - p[1][0] * p[2][2],
        p[0][0] * p[2][2] - p[2][0] * p[0][2],
        p[1][0] * p[0][2] - p[0][0] * p[1][2]
      ],
      [
        p[1][0] * p[2][1] - p[2][0] * p[1][1],
        p[2][0] * p[0][1] - p[0][0] * p[2][1],
        p[0][0] * p[1][1] - p[1][0] * p[0][1]
      ]
    ];
    const sToQ = squareToQuadrilateral(from);
    const transform2 = sToQ.map((i) => i.map((_, qx) => i.reduce((acc, v, j) => acc + v * qToS[j][qx], 0)));
    const res = new Bitmap(size);
    const points = fillArr(2 * size, 0);
    const pointsLength = points.length;
    for (let y = 0; y < size; y++) {
      const p2 = transform2;
      for (let i = 0; i < pointsLength - 1; i += 2) {
        const x = i / 2 + 0.5;
        const y2 = y + 0.5;
        const den = p2[2][0] * x + p2[2][1] * y2 + p2[2][2];
        points[i] = int((p2[0][0] * x + p2[0][1] * y2 + p2[0][2]) / den);
        points[i + 1] = int((p2[1][0] * x + p2[1][1] * y2 + p2[1][2]) / den);
      }
      for (let i = 0; i < pointsLength; i += 2) {
        const px = cap(points[i], 0, b.width - 1);
        const py = cap(points[i + 1], 0, b.height - 1);
        if (b.data[py][px])
          res.data[y][i / 2] = true;
      }
    }
    return res;
  }
  function readInfoBits(b) {
    const readBit = (x, y, out) => out << 1 | (b.data[y][x] ? 1 : 0);
    const size = b.height;
    let version1 = 0;
    for (let y = 5; y >= 0; y--)
      for (let x = size - 9; x >= size - 11; x--)
        version1 = readBit(x, y, version1);
    let version2 = 0;
    for (let x = 5; x >= 0; x--)
      for (let y = size - 9; y >= size - 11; y--)
        version2 = readBit(x, y, version2);
    let format1 = 0;
    for (let x = 0; x < 6; x++)
      format1 = readBit(x, 8, format1);
    format1 = readBit(7, 8, format1);
    format1 = readBit(8, 8, format1);
    format1 = readBit(8, 7, format1);
    for (let y = 5; y >= 0; y--)
      format1 = readBit(8, y, format1);
    let format2 = 0;
    for (let y = size - 1; y >= size - 7; y--)
      format2 = readBit(8, y, format2);
    for (let x = size - 8; x < size; x++)
      format2 = readBit(x, 8, format2);
    return { version1, version2, format1, format2 };
  }
  function parseInfo(b) {
    const popcnt = (a) => {
      let cnt = 0;
      while (a) {
        if (a & 1)
          cnt++;
        a >>= 1;
      }
      return cnt;
    };
    const size = b.height;
    const { version1, version2, format1, format2 } = readInfoBits(b);
    let format;
    const bestFormat = best();
    for (const ecc of ["medium", "low", "high", "quartile"]) {
      for (let mask = 0; mask < 8; mask++) {
        const bits = info.formatBits(ecc, mask);
        const cur = { ecc, mask };
        if (bits === format1 || bits === format2) {
          format = cur;
          break;
        }
        bestFormat.add(popcnt(format1 ^ bits), cur);
        if (format1 !== format2)
          bestFormat.add(popcnt(format2 ^ bits), cur);
      }
    }
    if (format === void 0 && bestFormat.score() <= MAX_BITS_ERROR)
      format = bestFormat.get();
    if (format === void 0)
      throw new Error("invalid format pattern");
    let version = info.size.decode(size);
    if (version < 7)
      validateVersion(version);
    else {
      version = void 0;
      const bestVer = best();
      for (let ver = 7; ver <= 40; ver++) {
        const bits = info.versionBits(ver);
        if (bits === version1 || bits === version2) {
          version = ver;
          break;
        }
        bestVer.add(popcnt(version1 ^ bits), ver);
        if (version1 !== version2)
          bestVer.add(popcnt(version2 ^ bits), ver);
      }
      if (version === void 0 && bestVer.score() <= MAX_BITS_ERROR)
        version = bestVer.get();
      if (version === void 0)
        throw new Error("invalid version pattern");
      if (info.size.encode(version) !== size)
        throw new Error("invalid version size");
    }
    return { version, ...format };
  }
  function decodeBitmap(b) {
    const size = b.height;
    if (size < 21 || (size & 3) !== 1 || size !== b.width)
      throw new Error(`decode: invalid size=${size}`);
    const { version, mask, ecc } = parseInfo(b);
    const tpl = drawTemplate(version, ecc, mask);
    const { total } = info.capacity(version, ecc);
    const bytes = new Uint8Array(total);
    let pos = 0;
    let buf = 0;
    let bitPos = 0;
    zigzag(tpl, mask, (x, y, m) => {
      bitPos++;
      buf <<= 1;
      buf |= +(!!b.data[y][x] !== m);
      if (bitPos !== 8)
        return;
      bytes[pos++] = buf;
      bitPos = 0;
      buf = 0;
    });
    if (pos !== total)
      throw new Error(`decode: pos=${pos}, total=${total}`);
    let bits = Array.from(interleave(version, ecc).decode(bytes)).map((i) => bin(i, 8)).join("");
    const readBits = (n) => {
      if (n > bits.length)
        throw new Error("Not enough bits");
      const val = bits.slice(0, n);
      bits = bits.slice(n);
      return val;
    };
    const toNum = (n) => Number(`0b${n}`);
    const modes = {
      "0000": "terminator",
      "0001": "numeric",
      "0010": "alphanumeric",
      "0100": "byte",
      "0111": "eci",
      "1000": "kanji"
    };
    let res = "";
    while (true) {
      if (bits.length < 4)
        break;
      const modeBits = readBits(4);
      const mode = modes[modeBits];
      if (mode === void 0)
        throw new Error(`Unknown modeBits=${modeBits} res="${res}"`);
      if (mode === "terminator")
        break;
      const countBits = info.lengthBits(version, mode);
      let count = toNum(readBits(countBits));
      if (mode === "numeric") {
        while (count >= 3) {
          const v = toNum(readBits(10));
          if (v >= 1e3)
            throw new Error(`numberic(3) = ${v}`);
          res += v.toString().padStart(3, "0");
          count -= 3;
        }
        if (count === 2) {
          const v = toNum(readBits(7));
          if (v >= 100)
            throw new Error(`numeric(2) = ${v}`);
          res += v.toString().padStart(2, "0");
        } else if (count === 1) {
          const v = toNum(readBits(4));
          if (v >= 10)
            throw new Error(`Numeric(1) = ${v}`);
          res += v.toString();
        }
      } else if (mode === "alphanumeric") {
        while (count >= 2) {
          const v = toNum(readBits(11));
          res += info.alphabet.alphanumerc.encode([Math.floor(v / 45), v % 45]).join("");
          count -= 2;
        }
        if (count === 1)
          res += info.alphabet.alphanumerc.encode([toNum(readBits(6))]).join("");
      } else if (mode === "byte") {
        let utf8 = [];
        for (let i = 0; i < count; i++)
          utf8.push(Number(`0b${readBits(8)}`));
        res += new TextDecoder().decode(new Uint8Array(utf8));
      } else
        throw new Error(`Unknown mode=${mode}`);
    }
    return res;
  }

  function decodeQR(img) {
    try {
      const bmp = toBitmap(img);
      const { bits } = detect(bmp);
      return decodeBitmap(bits);
    } catch (err) { if (!err.message.startsWith('Finder')) { console.error('QR decoder:', err.message) } }
    return null
  }

  return { decodeQR, encodeQR };
})();

// =================================== bip39 dictionary

var biplist = ("abandon,ability,able,about,above,absent,absorb,abstract,absurd,abuse,access,accident,account,accuse,achieve," +
"acid,acoustic,acquire,across,act,action,actor,actress,actual,adapt,add,addict,address,adjust,admit,adult,advance,advice,aerobic," +
"affair,afford,afraid,again,age,agent,agree,ahead,aim,air,airport,aisle,alarm,album,alcohol,alert,alien,all,alley,allow,almost," +
"alone,alpha,already,also,alter,always,amateur,amazing,among,amount,amused,analyst,anchor,ancient,anger,angle,angry,animal," +
"ankle,announce,annual,another,answer,antenna,antique,anxiety,any,apart,apology,appear,apple,approve,april,arch,arctic,area," +
"arena,argue,arm,armed,armor,army,around,arrange,arrest,arrive,arrow,art,artefact,artist,artwork,ask,aspect,assault,asset,assist," +
"assume,asthma,athlete,atom,attack,attend,attitude,attract,auction,audit,august,aunt,author,auto,autumn,average,avocado,avoid," +
"awake,aware,away,awesome,awful,awkward,axis,baby,bachelor,bacon,badge,bag,balance,balcony,ball,bamboo,banana,banner,bar,barely," +
"bargain,barrel,base,basic,basket,battle,beach,bean,beauty,because,become,beef,before,begin,behave,behind,believe,below,belt," +
"bench,benefit,best,betray,better,between,beyond,bicycle,bid,bike,bind,biology,bird,birth,bitter,black,blade,blame,blanket," +
"blast,bleak,bless,blind,blood,blossom,blouse,blue,blur,blush,board,boat,body,boil,bomb,bone,bonus,book,boost,border,boring," +
"borrow,boss,bottom,bounce,box,boy,bracket,brain,brand,brass,brave,bread,breeze,brick,bridge,brief,bright,bring,brisk,broccoli," +
"broken,bronze,broom,brother,brown,brush,bubble,buddy,budget,buffalo,build,bulb,bulk,bullet,bundle,bunker,burden,burger,burst," +
"bus,business,busy,butter,buyer,buzz,cabbage,cabin,cable,cactus,cage,cake,call,calm,camera,camp,can,canal,cancel,candy,cannon," +
"canoe,canvas,canyon,capable,capital,captain,car,carbon,card,cargo,carpet,carry,cart,case,cash,casino,castle,casual,cat,catalog," +
"catch,category,cattle,caught,cause,caution,cave,ceiling,celery,cement,census,century,cereal,certain,chair,chalk,champion,change," +
"chaos,chapter,charge,chase,chat,cheap,check,cheese,chef,cherry,chest,chicken,chief,child,chimney,choice,choose,chronic,chuckle," +
"chunk,churn,cigar,cinnamon,circle,citizen,city,civil,claim,clap,clarify,claw,clay,clean,clerk,clever,click,client,cliff,climb," +
"clinic,clip,clock,clog,close,cloth,cloud,clown,club,clump,cluster,clutch,coach,coast,coconut,code,coffee,coil,coin,collect," +
"color,column,combine,come,comfort,comic,common,company,concert,conduct,confirm,congress,connect,consider,control,convince," +
"cook,cool,copper,copy,coral,core,corn,correct,cost,cotton,couch,country,couple,course,cousin,cover,coyote,crack,cradle,craft," +
"cram,crane,crash,crater,crawl,crazy,cream,credit,creek,crew,cricket,crime,crisp,critic,crop,cross,crouch,crowd,crucial,cruel," +
"cruise,crumble,crunch,crush,cry,crystal,cube,culture,cup,cupboard,curious,current,curtain,curve,cushion,custom,cute,cycle," +
"dad,damage,damp,dance,danger,daring,dash,daughter,dawn,day,deal,debate,debris,decade,december,decide,decline,decorate,decrease," +
"deer,defense,define,defy,degree,delay,deliver,demand,demise,denial,dentist,deny,depart,depend,deposit,depth,deputy,derive," +
"describe,desert,design,desk,despair,destroy,detail,detect,develop,device,devote,diagram,dial,diamond,diary,dice,diesel,diet," +
"differ,digital,dignity,dilemma,dinner,dinosaur,direct,dirt,disagree,discover,disease,dish,dismiss,disorder,display,distance," +
"divert,divide,divorce,dizzy,doctor,document,dog,doll,dolphin,domain,donate,donkey,donor,door,dose,double,dove,draft,dragon," +
"drama,drastic,draw,dream,dress,drift,drill,drink,drip,drive,drop,drum,dry,duck,dumb,dune,during,dust,dutch,duty,dwarf,dynamic," +
"eager,eagle,early,earn,earth,easily,east,easy,echo,ecology,economy,edge,edit,educate,effort,egg,eight,either,elbow,elder,electric," +
"elegant,element,elephant,elevator,elite,else,embark,embody,embrace,emerge,emotion,employ,empower,empty,enable,enact,end,endless," +
"endorse,enemy,energy,enforce,engage,engine,enhance,enjoy,enlist,enough,enrich,enroll,ensure,enter,entire,entry,envelope,episode," +
"equal,equip,era,erase,erode,erosion,error,erupt,escape,essay,essence,estate,eternal,ethics,evidence,evil,evoke,evolve,exact," +
"example,excess,exchange,excite,exclude,excuse,execute,exercise,exhaust,exhibit,exile,exist,exit,exotic,expand,expect,expire," +
"explain,expose,express,extend,extra,eye,eyebrow,fabric,face,faculty,fade,faint,faith,fall,false,fame,family,famous,fan,fancy," +
"fantasy,farm,fashion,fat,fatal,father,fatigue,fault,favorite,feature,february,federal,fee,feed,feel,female,fence,festival," +
"fetch,fever,few,fiber,fiction,field,figure,file,film,filter,final,find,fine,finger,finish,fire,firm,first,fiscal,fish,fit," +
"fitness,fix,flag,flame,flash,flat,flavor,flee,flight,flip,float,flock,floor,flower,fluid,flush,fly,foam,focus,fog,foil,fold," +
"follow,food,foot,force,forest,forget,fork,fortune,forum,forward,fossil,foster,found,fox,fragile,frame,frequent,fresh,friend," +
"fringe,frog,front,frost,frown,frozen,fruit,fuel,fun,funny,furnace,fury,future,gadget,gain,galaxy,gallery,game,gap,garage,garbage," +
"garden,garlic,garment,gas,gasp,gate,gather,gauge,gaze,general,genius,genre,gentle,genuine,gesture,ghost,giant,gift,giggle," +
"ginger,giraffe,girl,give,glad,glance,glare,glass,glide,glimpse,globe,gloom,glory,glove,glow,glue,goat,goddess,gold,good,goose," +
"gorilla,gospel,gossip,govern,gown,grab,grace,grain,grant,grape,grass,gravity,great,green,grid,grief,grit,grocery,group,grow," +
"grunt,guard,guess,guide,guilt,guitar,gun,gym,habit,hair,half,hammer,hamster,hand,happy,harbor,hard,harsh,harvest,hat,have," +
"hawk,hazard,head,health,heart,heavy,hedgehog,height,hello,helmet,help,hen,hero,hidden,high,hill,hint,hip,hire,history,hobby," +
"hockey,hold,hole,holiday,hollow,home,honey,hood,hope,horn,horror,horse,hospital,host,hotel,hour,hover,hub,huge,human,humble," +
"humor,hundred,hungry,hunt,hurdle,hurry,hurt,husband,hybrid,ice,icon,idea,identify,idle,ignore,ill,illegal,illness,image,imitate," +
"immense,immune,impact,impose,improve,impulse,inch,include,income,increase,index,indicate,indoor,industry,infant,inflict,inform," +
"inhale,inherit,initial,inject,injury,inmate,inner,innocent,input,inquiry,insane,insect,inside,inspire,install,intact,interest," +
"into,invest,invite,involve,iron,island,isolate,issue,item,ivory,jacket,jaguar,jar,jazz,jealous,jeans,jelly,jewel,job,join," +
"joke,journey,joy,judge,juice,jump,jungle,junior,junk,just,kangaroo,keen,keep,ketchup,key,kick,kid,kidney,kind,kingdom,kiss," +
"kit,kitchen,kite,kitten,kiwi,knee,knife,knock,know,lab,label,labor,ladder,lady,lake,lamp,language,laptop,large,later,latin," +
"laugh,laundry,lava,law,lawn,lawsuit,layer,lazy,leader,leaf,learn,leave,lecture,left,leg,legal,legend,leisure,lemon,lend,length," +
"lens,leopard,lesson,letter,level,liar,liberty,library,license,life,lift,light,like,limb,limit,link,lion,liquid,list,little," +
"live,lizard,load,loan,lobster,local,lock,logic,lonely,long,loop,lottery,loud,lounge,love,loyal,lucky,luggage,lumber,lunar," +
"lunch,luxury,lyrics,machine,mad,magic,magnet,maid,mail,main,major,make,mammal,man,manage,mandate,mango,mansion,manual,maple," +
"marble,march,margin,marine,market,marriage,mask,mass,master,match,material,math,matrix,matter,maximum,maze,meadow,mean,measure," +
"meat,mechanic,medal,media,melody,melt,member,memory,mention,menu,mercy,merge,merit,merry,mesh,message,metal,method,middle," +
"midnight,milk,million,mimic,mind,minimum,minor,minute,miracle,mirror,misery,miss,mistake,mix,mixed,mixture,mobile,model,modify," +
"mom,moment,monitor,monkey,monster,month,moon,moral,more,morning,mosquito,mother,motion,motor,mountain,mouse,move,movie,much," +
"muffin,mule,multiply,muscle,museum,mushroom,music,must,mutual,myself,mystery,myth,naive,name,napkin,narrow,nasty,nation,nature," +
"near,neck,need,negative,neglect,neither,nephew,nerve,nest,net,network,neutral,never,news,next,nice,night,noble,noise,nominee," +
"noodle,normal,north,nose,notable,note,nothing,notice,novel,now,nuclear,number,nurse,nut,oak,obey,object,oblige,obscure,observe," +
"obtain,obvious,occur,ocean,october,odor,off,offer,office,often,oil,okay,old,olive,olympic,omit,once,one,onion,online,only," +
"open,opera,opinion,oppose,option,orange,orbit,orchard,order,ordinary,organ,orient,original,orphan,ostrich,other,outdoor,outer," +
"output,outside,oval,oven,over,own,owner,oxygen,oyster,ozone,pact,paddle,page,pair,palace,palm,panda,panel,panic,panther,paper," +
"parade,parent,park,parrot,party,pass,patch,path,patient,patrol,pattern,pause,pave,payment,peace,peanut,pear,peasant,pelican," +
"pen,penalty,pencil,people,pepper,perfect,permit,person,pet,phone,photo,phrase,physical,piano,picnic,picture,piece,pig,pigeon," +
"pill,pilot,pink,pioneer,pipe,pistol,pitch,pizza,place,planet,plastic,plate,play,please,pledge,pluck,plug,plunge,poem,poet," +
"point,polar,pole,police,pond,pony,pool,popular,portion,position,possible,post,potato,pottery,poverty,powder,power,practice," +
"praise,predict,prefer,prepare,present,pretty,prevent,price,pride,primary,print,priority,prison,private,prize,problem,process," +
"produce,profit,program,project,promote,proof,property,prosper,protect,proud,provide,public,pudding,pull,pulp,pulse,pumpkin," +
"punch,pupil,puppy,purchase,purity,purpose,purse,push,put,puzzle,pyramid,quality,quantum,quarter,question,quick,quit,quiz,quote," +
"rabbit,raccoon,race,rack,radar,radio,rail,rain,raise,rally,ramp,ranch,random,range,rapid,rare,rate,rather,raven,raw,razor," +
"ready,real,reason,rebel,rebuild,recall,receive,recipe,record,recycle,reduce,reflect,reform,refuse,region,regret,regular,reject," +
"relax,release,relief,rely,remain,remember,remind,remove,render,renew,rent,reopen,repair,repeat,replace,report,require,rescue," +
"resemble,resist,resource,response,result,retire,retreat,return,reunion,reveal,review,reward,rhythm,rib,ribbon,rice,rich,ride," +
"ridge,rifle,right,rigid,ring,riot,ripple,risk,ritual,rival,river,road,roast,robot,robust,rocket,romance,roof,rookie,room,rose," +
"rotate,rough,round,route,royal,rubber,rude,rug,rule,run,runway,rural,sad,saddle,sadness,safe,sail,salad,salmon,salon,salt," +
"salute,same,sample,sand,satisfy,satoshi,sauce,sausage,save,say,scale,scan,scare,scatter,scene,scheme,school,science,scissors," +
"scorpion,scout,scrap,screen,script,scrub,sea,search,season,seat,second,secret,section,security,seed,seek,segment,select,sell," +
"seminar,senior,sense,sentence,series,service,session,settle,setup,seven,shadow,shaft,shallow,share,shed,shell,sheriff,shield," +
"shift,shine,ship,shiver,shock,shoe,shoot,shop,short,shoulder,shove,shrimp,shrug,shuffle,shy,sibling,sick,side,siege,sight," +
"sign,silent,silk,silly,silver,similar,simple,since,sing,siren,sister,situate,six,size,skate,sketch,ski,skill,skin,skirt,skull," +
"slab,slam,sleep,slender,slice,slide,slight,slim,slogan,slot,slow,slush,small,smart,smile,smoke,smooth,snack,snake,snap,sniff," +
"snow,soap,soccer,social,sock,soda,soft,solar,soldier,solid,solution,solve,someone,song,soon,sorry,sort,soul,sound,soup,source," +
"south,space,spare,spatial,spawn,speak,special,speed,spell,spend,sphere,spice,spider,spike,spin,spirit,split,spoil,sponsor," +
"spoon,sport,spot,spray,spread,spring,spy,square,squeeze,squirrel,stable,stadium,staff,stage,stairs,stamp,stand,start,state," +
"stay,steak,steel,stem,step,stereo,stick,still,sting,stock,stomach,stone,stool,story,stove,strategy,street,strike,strong,struggle," +
"student,stuff,stumble,style,subject,submit,subway,success,such,sudden,suffer,sugar,suggest,suit,summer,sun,sunny,sunset,super," +
"supply,supreme,sure,surface,surge,surprise,surround,survey,suspect,sustain,swallow,swamp,swap,swarm,swear,sweet,swift,swim," +
"swing,switch,sword,symbol,symptom,syrup,system,table,tackle,tag,tail,talent,talk,tank,tape,target,task,taste,tattoo,taxi,teach," +
"team,tell,ten,tenant,tennis,tent,term,test,text,thank,that,theme,then,theory,there,they,thing,this,thought,three,thrive,throw," +
"thumb,thunder,ticket,tide,tiger,tilt,timber,time,tiny,tip,tired,tissue,title,toast,tobacco,today,toddler,toe,together,toilet," +
"token,tomato,tomorrow,tone,tongue,tonight,tool,tooth,top,topic,topple,torch,tornado,tortoise,toss,total,tourist,toward,tower," +
"town,toy,track,trade,traffic,tragic,train,transfer,trap,trash,travel,tray,treat,tree,trend,trial,tribe,trick,trigger,trim," +
"trip,trophy,trouble,truck,true,truly,trumpet,trust,truth,try,tube,tuition,tumble,tuna,tunnel,turkey,turn,turtle,twelve,twenty," +
"twice,twin,twist,two,type,typical,ugly,umbrella,unable,unaware,uncle,uncover,under,undo,unfair,unfold,unhappy,uniform,unique," +
"unit,universe,unknown,unlock,until,unusual,unveil,update,upgrade,uphold,upon,upper,upset,urban,urge,usage,use,used,useful," +
"useless,usual,utility,vacant,vacuum,vague,valid,valley,valve,van,vanish,vapor,various,vast,vault,vehicle,velvet,vendor,venture," +
"venue,verb,verify,version,very,vessel,veteran,viable,vibrant,vicious,victory,video,view,village,vintage,violin,virtual,virus," +
"visa,visit,visual,vital,vivid,vocal,voice,void,volcano,volume,vote,voyage,wage,wagon,wait,walk,wall,walnut,want,warfare,warm," +
"warrior,wash,wasp,waste,water,wave,way,wealth,weapon,wear,weasel,weather,web,wedding,weekend,weird,welcome,west,wet,whale," +
"what,wheat,wheel,when,where,whip,whisper,wide,width,wife,wild,will,win,window,wine,wing,wink,winner,winter,wire,wisdom,wise," +
"wish,witness,wolf,woman,wonder,wood,wool,word,work,world,worry,worth,wrap,wreck,wrestle,wrist,write,wrong,yard,year,yellow," +
"you,young,youth,zebra,zero,zone,zoo").split(',')
const bipdict = {}; biplist.forEach((w, i) => bipdict[w] = i)

</script>

<script>
async function resetCache() {
  const keys = await caches.keys()
  for (const key of keys) await caches.delete(key)
  const regs = await navigator.serviceWorker.getRegistrations()
  for (const reg of regs) await reg.unregister()
  location.href = location.pathname
}
// if ('serviceWorker' in navigator) {
//   navigator.serviceWorker.register('sw.js')
//     .then(reg => {
//       console.log('Service worker registered:', reg.scope);
//     })
//     .catch(err => {
//       console.error('Service worker registration failed:', err);
//     });
// }

</script>
</body>
</html>